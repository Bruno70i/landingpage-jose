/**
  * name: @tresjs/cientos
  * version: v5.1.1
  * (c) 2025
  * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
  * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
  */
import * as vue0 from "vue";
import { ComputedRef, MaybeRef, MaybeRefOrGetter, Ref } from "vue";
import * as _tresjs_core0 from "@tresjs/core";
import { TresColor, TresObject, TresObject3D, TresOptions, TresRenderer, TresVector2, TresVector3, VectorFlexibleParams } from "@tresjs/core";
import * as three5 from "three";
import { AnimationAction, AnimationClip, AnimationMixer, Blending, Box3, BoxGeometry, BufferGeometry, Camera, CircleGeometry, Clock, Color, ColorRepresentation, ConeGeometry, CubeCamera, CubeTexture, CylinderGeometry, DodecahedronGeometry, Euler, Fog, FogExp2, Group, IcosahedronGeometry, InstancedMesh, InterleavedBuffer, LOD, LineSegments, LoadingManager, Mesh, MeshBasicMaterialParameters, Object3D, Object3DEventMap, OctahedronGeometry, OrthographicCamera, PerspectiveCamera, PlaneGeometry, Points, PointsMaterial, PointsMaterialParameters, PositionalAudio, Quaternion, RenderTargetOptions, RingGeometry, Scene, ShaderMaterial, Side, Sphere, SphereGeometry, TetrahedronGeometry, Texture, TorusGeometry, TorusKnotGeometry, TubeGeometry, Vector2, Vector3, VideoTexture, WebGLCubeRenderTarget, WebGLRenderTarget } from "three";
import { Fn, Mutable } from "@vueuse/core";
import * as three_stdlib0 from "three-stdlib";
import { GLTF, MapControls, MarchingCubes, OrbitControls, Reflector, SVGResult, Sky, TransformControls } from "three-stdlib";
import BaseCameraControls, { default as CameraControls } from "camera-controls";

//#region src/core/abstractions/AnimatedSprite/Atlas.d.ts

type AtlasData = TexturePackerFrameDataArray | TexturePackerFrameDataObject;
type Atlasish = AtlasData | [number, number] | number;
interface TexturePackerFrameData {
  filename: string;
  frame: {
    x: number;
    y: number;
    w: number;
    h: number;
  };
}
interface TexturePackerFrameDataArray {
  frames: TexturePackerFrameData[];
}
interface TexturePackerFrameDataObject {
  frames: Record<string, TexturePackerFrameData>;
}
//#endregion
//#region src/core/abstractions/AnimatedSprite/component.vue.d.ts
interface AnimatedSpriteProps {
  /** URL of the image texture or an image dataURL. This prop is not reactive. */
  image: string;
  /**
   * If `string`, the URL of the JSON atlas.
   * If `number`, the number of columns in the texture.
   * If `[number, number]`, the number of columns/rows in the texture.
   * If `AtlasData`, the atlas as a JS object.
   * This prop is not reactive.
   */
  atlas: string | Atlasish;
  /**
  * Specify playback frame order and repeated frames (delays). `definitions` is a record where keys are atlas animation names and values are strings containing an animation definition.
  * A "animation definition" comma-separated string of frame numbers with optional parentheses-surrounded durations.
  * Here is how various definition strings convert to arrays of frames for playback:
  * "0,2,1" - [0,2,1], i.e., play frame 0, 2, then 1.
  * "2(10)" - [2,2,2,2,2,2,2,2,2,2], i.e., play from 2 10 times.
  * "1-4" - [1,2,3,4]
  * "10-5(2)" - [10,10,9,9,8,8,7,7,6,6,5,5]
  * "1-4(3),10(2)" - [1,1,1,2,2,2,3,3,3,4,4,4,10,10]
   */
  definitions?: Record<string, string>;
  /** Desired frames per second of the animation. */
  fps?: number;
  /** Whether or not the animation should loop. */
  loop?: boolean;
  /** If `string`, name of the animation to play. If `[number, number]`, start and end frames of the animation. If `number`, frame number to display. */
  animation?: string | [number, number] | number;
  /** Whether the animation is paused. */
  paused?: boolean;
  /** Whether to play the animation in reverse. */
  reversed?: boolean;
  /** Whether the sprite should be flipped, left to right. */
  flipX?: boolean;
  /** For a non-looping animation, when the animation ends, whether to display the zeroth frame. */
  resetOnEnd?: boolean;
  /** Whether to display the object as a THREE.Sprite. [See THREE.Sprite](https://threejs.org/docs/?q=sprite#api/en/objects/Sprite) */
  asSprite?: boolean;
  /** Anchor point of the object. A value of [0.5, 0.5] corresponds to the center. [0, 0] is left, bottom. */
  center?: TresVector2;
  /** Alpha test value for the material. [See THREE.Material.alphaTest](https://threejs.org/docs/#api/en/materials/Material.alphaTest) */
  alphaTest?: number;
  /** Depth test value for the material. [See THREE.Material.depthTest](https://threejs.org/docs/#api/en/materials/Material.depthTest) */
  depthTest?: boolean;
  /** Depth write value for the material. [See THREE.Material.depthWrite](https://threejs.org/docs/#api/en/materials/Material.depthWrite) */
  depthWrite?: boolean;
}
declare var __VLS_33: {};
type __VLS_Slots$41 = {} & {
  default?: (props: typeof __VLS_33) => any;
};
declare const __VLS_base$41: vue0.DefineComponent<AnimatedSpriteProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {} & {
  loop: (frameName: string) => any;
  frame: (frameName: string) => any;
  end: (frameName: string) => any;
}, string, vue0.PublicProps, Readonly<AnimatedSpriteProps> & Readonly<{
  onLoop?: ((frameName: string) => any) | undefined;
  onFrame?: ((frameName: string) => any) | undefined;
  onEnd?: ((frameName: string) => any) | undefined;
}>, {
  fps: number;
  loop: boolean;
  animation: string | [number, number] | number;
  paused: boolean;
  reversed: boolean;
  flipX: boolean;
  resetOnEnd: boolean;
  asSprite: boolean;
  center: TresVector2;
  alphaTest: number;
  depthTest: boolean;
  depthWrite: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$81: __VLS_WithSlots$41<typeof __VLS_base$41, __VLS_Slots$41>;
declare const _default$2: typeof __VLS_export$81;
type __VLS_WithSlots$41<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/CubeCamera/useCubeCamera.d.ts
interface CubeCameraOptions {
  /** Resolution of the FBO, 255 */
  resolution?: MaybeRefOrGetter<number>;
  /** Camera near, 0.1 */
  near?: MaybeRefOrGetter<number>;
  /** Camera far, 1000 */
  far?: MaybeRefOrGetter<number>;
  /** Custom environment map that is temporarily set as the scene's background */
  envMap?: MaybeRefOrGetter<Texture>;
  /** Custom fog that is temporarily set as the scene's fog */
  fog?: MaybeRefOrGetter<Fog | FogExp2>;
  /** Renderer */
  renderer?: MaybeRefOrGetter<TresRenderer>;
  /** Scene */
  scene?: MaybeRefOrGetter<Scene>;
}
//#endregion
//#region src/core/abstractions/CubeCamera/component.vue.d.ts
type Props$2 = {
  /** Number of frames to render, Infinity */
  frames?: MaybeRefOrGetter<number>;
} & CubeCameraOptions;
declare var __VLS_13$17: {};
type __VLS_Slots$40 = {} & {
  default?: (props: typeof __VLS_13$17) => any;
};
declare const __VLS_base$40: vue0.DefineComponent<Props$2, {
  instance: vue0.ShallowRef<Group<three5.Object3DEventMap> | undefined, Group<three5.Object3DEventMap> | undefined>;
  fbo: vue0.ComputedRef<three5.WebGLCubeRenderTarget>;
  camera: vue0.ComputedRef<three5.CubeCamera>;
  update: () => void;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<Props$2> & Readonly<{}>, {
  frames: MaybeRefOrGetter<number>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$80: __VLS_WithSlots$40<typeof __VLS_base$40, __VLS_Slots$40>;
declare const _default$13: typeof __VLS_export$80;
type __VLS_WithSlots$40<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/Billboard.vue.d.ts
interface BillboardProps {
  /**
   * Whether the Billboard should face the camera automatically on every frame.
   */
  autoUpdate?: boolean;
  /**
   * Whether to lock the x-axis.
   */
  lockX?: boolean;
  /**
   * Whether to lock the y-axis.
   */
  lockY?: boolean;
  /**
   * Whether to lock the z-axis.
   */
  lockZ?: boolean;
}
declare function update$1(camera?: Camera): void;
declare var __VLS_15$2: {};
type __VLS_Slots$39 = {} & {
  default?: (props: typeof __VLS_15$2) => any;
};
declare const __VLS_base$39: vue0.DefineComponent<BillboardProps, {
  instance: vue0.ShallowRef<Group<three5.Object3DEventMap>, Group<three5.Object3DEventMap>>;
  update: typeof update$1;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<BillboardProps> & Readonly<{}>, {
  autoUpdate: boolean;
  lockX: boolean;
  lockY: boolean;
  lockZ: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$79: __VLS_WithSlots$39<typeof __VLS_base$39, __VLS_Slots$39>;
declare const _default$4: typeof __VLS_export$79;
type __VLS_WithSlots$39<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/GlobalAudio.d.ts
interface AudioProps {
  /**
   * Path to your audio file.
   * @type {string}
   * @memberof AudioProps
   *
   */
  src: string;
  /**
   * Id of the DOM element that trigger the play/pause state.
   * @type {string}
   * @memberof AudioProps
   * @default renderer.domElement
   *
   */
  playTrigger?: string;
  /**
   * Id of the DOM element that trigger the stop state.
   * @type {string}
   * @memberof AudioProps
   * @default
   *
   */
  stopTrigger?: string;
  /**
   * If the audio must be replayed when ends.
   * @type {boolean}
   * @memberof AudioProps
   * @default false
   *
   */
  loop?: boolean;
  /**
   * Volume of the audio.
   * @type {number}
   * @memberof AudioProps
   * @default 0.5
   *
   */
  volume?: number;
  /**
   * PlaybackRate of the audio.
   * @type {number}
   * @memberof AudioProps
   * @default 1
   *
   */
  playbackRate?: number;
}
declare const GlobalAudio: vue0.DefineComponent<AudioProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<AudioProps> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
//#endregion
//#region src/core/abstractions/GradientTexture.vue.d.ts
type GradientType = 'linear' | 'radial';
interface Props$1 {
  /**
   * A `number[]` of values between `0` and `1` representing the color positions in the gradient. `stops.length` should match `color.
   */
  stops: Array<number>;
  /**
   * A `THREE.ColorRepresentation[]` representing the colors in the gradient.
   */
  colors: Array<three5.ColorRepresentation>;
  /**
   * Where the component should be attached within its parent.
   */
  attach?: string;
  /**
   * Height of the canvas used to draw the gradient.
   */
  height?: number;
  /**
   * Width of the canvas used to draw the gradient.
   */
  width?: number;
  /**
   * `'linear' \| 'radial'` Type of gradient to draw.
   */
  type?: GradientType;
  /**
   * Radius of the inner circle of a radial gradient.
   */
  innerCircleRadius?: number;
  /**
   * Radius of the outer circle of a radial gradient.
   */
  outerCircleRadius?: string | number;
}
declare const __VLS_export$78: vue0.DefineComponent<Props$1, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<Props$1> & Readonly<{}>, {
  type: GradientType;
  attach: string;
  height: number;
  width: number;
  innerCircleRadius: number;
  outerCircleRadius: string | number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$24: typeof __VLS_export$78;
//#endregion
//#region src/core/abstractions/Image/component.vue.d.ts
declare var __VLS_8$11: {};
type __VLS_Slots$38 = {} & {
  default?: (props: typeof __VLS_8$11) => any;
};
declare const __VLS_base$38: vue0.DefineSetupFnComponent<Record<string, any>, {}, {}, Record<string, any> & {}, vue0.PublicProps>;
declare const __VLS_export$77: __VLS_WithSlots$38<typeof __VLS_base$38, __VLS_Slots$38>;
declare const _default$30: typeof __VLS_export$77;
type __VLS_WithSlots$38<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/Lensflare/LensflareImpl.d.ts
declare class Lensflare extends Mesh {
  static Geometry: BufferGeometry;
  isLensflare: boolean;
  type: string;
  addElement(_: LensflareElement): void;
  dispose(): void;
  constructor();
}
declare class LensflareElement {
  texture: Texture;
  size: number;
  distance: number;
  color: Color;
  static Shader: {
    name: string;
    vertexShader: string;
    fragmentShader: string;
    uniforms: Record<string, any>;
  };
  constructor(texture: Texture, size?: number, distance?: number, color?: Color);
}
//#endregion
//#region src/core/abstractions/Lensflare/index.d.ts
interface SeedProps {
  texture: string[];
  color: TresColor[];
  distance: [number, number];
  size: [number, number];
  length: [number, number];
  seed?: number;
}
interface LensflareElementProps {
  texture: Texture | string;
  size: number;
  distance: number;
  color: TresColor;
}
//#endregion
//#region src/core/abstractions/Lensflare/component.vue.d.ts
interface LensflareProps {
  /**
   * scale of the lensflare
   */
  scale?: number;
  /**
   * array of lensflare element properties
   */
  elements?: Partial<LensflareElementProps>[];
  /**
   * random seed for generating random seeded elements
   */
  seed?: number;
  /**
   * specifications for generating random seeded elements
   */
  seedProps?: SeedProps[];
  /**
   * default color of lensflare elements
   */
  color?: TresColor;
  /**
   *  default distance of lensflare elements from flare center
   */
  distance?: number;
  /**
   *  default size of lensflare elements
   */
  size?: number;
  /**
   * default texture of lensflare elements
   */
  texture?: Texture | string;
}
declare const __VLS_export$76: vue0.DefineComponent<LensflareProps, {
  instance: vue0.ShallowRef<Lensflare | undefined, Lensflare | undefined>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<LensflareProps> & Readonly<{}>, {
  scale: number;
  color: TresColor;
  texture: Texture | string;
  size: number;
  elements: Partial<LensflareElementProps>[];
  seed: number;
  seedProps: SeedProps[];
  distance: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$33: typeof __VLS_export$76;
//#endregion
//#region src/core/abstractions/Levioso.vue.d.ts
type __VLS_Props$6 = {
  speed?: number;
  rotationFactor?: number;
  floatFactor?: number;
  range?: [number, number];
};
declare var __VLS_8$10: {};
type __VLS_Slots$37 = {} & {
  default?: (props: typeof __VLS_8$10) => any;
};
declare const __VLS_base$37: vue0.DefineComponent<__VLS_Props$6, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<__VLS_Props$6> & Readonly<{}>, {
  speed: number;
  rotationFactor: number;
  floatFactor: number;
  range: [number, number];
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$75: __VLS_WithSlots$37<typeof __VLS_base$37, __VLS_Slots$37>;
declare const _default$34: typeof __VLS_export$75;
type __VLS_WithSlots$37<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCube.vue.d.ts
interface MarchingCubeProps {
  strength?: number;
  subtract?: number;
  color?: ColorRepresentation;
}
declare const __VLS_export$74: vue0.DefineComponent<MarchingCubeProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MarchingCubeProps> & Readonly<{}>, {
  strength: number;
  subtract: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$38: typeof __VLS_export$74;
//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingCubes.vue.d.ts
interface MarchingCubesProps {
  resolution?: number;
  maxPolyCount?: number;
  enableUvs?: boolean;
  enableColors?: boolean;
}
declare var __VLS_7$1: {};
type __VLS_Slots$36 = {} & {
  default?: (props: typeof __VLS_7$1) => any;
};
declare const __VLS_base$36: vue0.DefineComponent<MarchingCubesProps, {
  instance: vue0.ComputedRef<MarchingCubes>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MarchingCubesProps> & Readonly<{}>, {
  resolution: number;
  maxPolyCount: number;
  enableUvs: boolean;
  enableColors: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$73: __VLS_WithSlots$36<typeof __VLS_base$36, __VLS_Slots$36>;
declare const _default$39: typeof __VLS_export$73;
type __VLS_WithSlots$36<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/MarchingCubes/MarchingPlane.vue.d.ts
interface MarchingPlaneProps {
  planeType?: 'x' | 'y' | 'z';
  strength?: number;
  subtract?: number;
}
declare const __VLS_export$72: vue0.DefineComponent<MarchingPlaneProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MarchingPlaneProps> & Readonly<{}>, {
  strength: number;
  subtract: number;
  planeType: "x" | "y" | "z";
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$40: typeof __VLS_export$72;
//#endregion
//#region src/core/abstractions/Mask/component.vue.d.ts
interface MaskProps {
  /** Id of the stencil buffer to use. Each mask must have an id. Multiple masks can refer to the same id. */
  id: number;
  /** Whether the colors of the masks own material will leak through, default: false */
  colorWrite?: boolean;
  /** Whether the depth of the masks own material will leak through, default: false */
  depthWrite?: boolean;
}
declare var __VLS_8$9: {};
type __VLS_Slots$35 = {} & {
  default?: (props: typeof __VLS_8$9) => any;
};
declare const __VLS_base$35: vue0.DefineComponent<MaskProps, {
  instance: vue0.ShallowRef<Mesh<three5.BufferGeometry<three5.NormalBufferAttributes, three5.BufferGeometryEventMap>, three5.Material | three5.Material[], three5.Object3DEventMap> | undefined, Mesh<three5.BufferGeometry<three5.NormalBufferAttributes, three5.BufferGeometryEventMap>, three5.Material | three5.Material[], three5.Object3DEventMap> | undefined>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MaskProps> & Readonly<{}>, {
  depthWrite: boolean;
  colorWrite: boolean;
  id: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$71: __VLS_WithSlots$35<typeof __VLS_base$35, __VLS_Slots$35>;
declare const _default$41: typeof __VLS_export$71;
type __VLS_WithSlots$35<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/MouseParallax.vue.d.ts
interface MouseParallaxProps {
  /**
   * Whether to disable the mouse controls.
   * @type {boolean}
   * @default false
   * @memberof MouseParallaxProps
   *
   */
  disabled?: boolean;
  /**
   * The factor to multiply the mouse movement by.
   * @type {number | [number, number]}
   * @default 2.5
   * @memberof MouseParallaxProps
   *
   */
  factor?: number | [number, number];
  /**
   * The factor to smooth the mouse movement by.
   * @type {number | [number, number]}
   * @default 2.5
   * @memberof MouseParallaxProps
   *
   */
  ease?: number | [number, number];
  /**
   * Whether to apply the parallax effect to the local canvas.
   * @type {boolean}
   * @default false
   * @memberof MouseParallaxProps
   *
   */
  local?: boolean;
}
declare const __VLS_export$70: vue0.DefineComponent<MouseParallaxProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MouseParallaxProps> & Readonly<{}>, {
  local: boolean;
  disabled: boolean;
  factor: number | [number, number];
  ease: number | [number, number];
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$46: typeof __VLS_export$70;
//#endregion
//#region src/core/abstractions/Outline/component.vue.d.ts
interface OutlineProps {
  /** Outline color, default: black */
  color?: TresColor;
  /** Line thickness is independent of zoom, default: false */
  screenspace?: boolean;
  /** Outline opacity, default: 1 */
  opacity?: number;
  /** Outline transparency, default: false */
  transparent?: boolean;
  /** Outline thickness, default 0.05 */
  thickness?: number;
  /** Geometry crease angle (-1 === no crease), default: Math.PI, See [BufferGeometryUtils.toCreasedNormals](https://threejs.org/docs/#examples/en/utils/BufferGeometryUtils.toCreasedNormals) */
  angle?: number;
  toneMapped?: boolean;
  polygonOffset?: boolean;
  polygonOffsetFactor?: number;
  renderOrder?: number;
}
declare const __VLS_export$69: vue0.DefineComponent<OutlineProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<OutlineProps> & Readonly<{}>, {
  color: TresColor;
  toneMapped: boolean;
  transparent: boolean;
  opacity: number;
  polygonOffset: boolean;
  polygonOffsetFactor: number;
  screenspace: boolean;
  thickness: number;
  angle: number;
  renderOrder: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$50: typeof __VLS_export$69;
//#endregion
//#region src/core/abstractions/PositionalAudio.vue.d.ts
interface PositionalAudioProps {
  ready: boolean;
  url: string;
  distance?: number;
  helper?: boolean;
  loop?: boolean;
  autoplay?: boolean;
  innerAngle?: number;
  outerAngle?: number;
  outerGain?: number;
}
declare const __VLS_export$68: vue0.DefineComponent<PositionalAudioProps, {
  instance: vue0.ShallowRef<PositionalAudio | null, PositionalAudio | null>;
  play: () => void;
  stop: () => void;
  pause: () => void;
  dispose: () => void;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  isPlaying: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<PositionalAudioProps> & Readonly<{
  onIsPlaying?: ((...args: any[]) => any) | undefined;
}>, {
  loop: boolean;
  distance: number;
  ready: boolean;
  helper: boolean;
  autoplay: boolean;
  innerAngle: number;
  outerAngle: number;
  outerGain: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$54: typeof __VLS_export$68;
//#endregion
//#region src/core/abstractions/Reflector.vue.d.ts
interface ReflectorProps {
  /**
   * The color of the reflector.
   *
   * @default '#333'
   * @type {TresColor}
   * @memberof ReflectorProps
   *
   */
  color?: TresColor;
  /**
   * The textureWidth of the internal WebGLRenderTarget.
   *
   * @default window.innerWidth
   * @type {number}
   * @memberof ReflectorProps
   *
   */
  textureWidth?: number;
  /**
   * The textureHeight of the internal WebGLRenderTarget.
   *
   * @default window.innerHeight
   * @type {number}
   * @memberof ReflectorProps
   *
   */
  textureHeight?: number;
  /**
   * The clipBias.
   *
   * @default 0
   * @type {number}
   * @memberof ReflectorProps
   *
   */
  clipBias?: number;
  /**
   * The multisample.
   *
   * @default 4
   * @type {number}
   * @memberof ReflectorProps
   *
   */
  multisample?: number;
  /**
   * Custom shader.
   *
   * @default Reflector.ReflectorShader
   * @type {object}
   * @memberof ReflectorProps
   *
   */
  shader?: object;
}
declare var __VLS_8$8: {};
type __VLS_Slots$34 = {} & {
  default?: (props: typeof __VLS_8$8) => any;
};
declare const __VLS_base$34: vue0.DefineComponent<ReflectorProps, {
  instance: vue0.ShallowRef<Reflector | undefined, Reflector | undefined>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<ReflectorProps> & Readonly<{}>, {
  color: TresColor;
  textureWidth: number;
  textureHeight: number;
  clipBias: number;
  multisample: number;
  shader: object;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$67: __VLS_WithSlots$34<typeof __VLS_base$34, __VLS_Slots$34>;
declare const _default$58: typeof __VLS_export$67;
type __VLS_WithSlots$34<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/ScreenSpace.vue.d.ts
interface ScreenSpaceProps {
  depth?: number;
  top?: number;
  bottom?: number;
  left?: number;
  right?: number;
}
declare var __VLS_13$16: {};
type __VLS_Slots$33 = {} & {
  default?: (props: typeof __VLS_13$16) => any;
};
declare const __VLS_base$33: vue0.DefineComponent<ScreenSpaceProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<ScreenSpaceProps> & Readonly<{}>, {
  depth: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$66: __VLS_WithSlots$33<typeof __VLS_base$33, __VLS_Slots$33>;
declare const _default$64: typeof __VLS_export$66;
type __VLS_WithSlots$33<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/Text3D.vue.d.ts
interface Glyph {
  _cachedOutline: string[];
  ha: number;
  o: string;
}
interface FontData {
  boundingBox: {
    yMax: number;
    yMin: number;
  };
  familyName: string;
  glyphs: {
    [k: string]: Glyph;
  };
  resolution: number;
  underlineThickness: number;
}
interface Text3DProps {
  /**
   *
   *  The JSON font to use for the text.
   *  Text3D requires fonts in JSON format generated through [typeface.json](http://gero3.github.io/facetype.js)
   *
   * @type {(FontData | string)}
   * @memberof Text3DProps
   * @see https://threejs.org/docs/index.html?q=TEXT#examples/en/geometries/TextGeometry
   */
  font: FontData | string;
  /**
   * The text to display.
   *
   * @type {string}
   * @memberof Text3DProps
   */
  text?: string;
  /**
   * The size of the text.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 0.5
   */
  size?: number;
  /**
   * The height of the text.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 0.2
   */
  height?: number;
  /**
   * The curve segments of the text.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 5
   */
  curveSegments?: number;
  /**
   * Turn on bevel
   *
   * @type {boolean}
   * @memberof Text3DProps
   * @default true
   */
  bevelEnabled?: boolean;
  /**
   * How deep into text bevel goes.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 0.05
   */
  bevelThickness?: number;
  /**
   * How far from text outline is bevel.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 0.02
   */
  bevelSize?: number;
  /**
   * How far from text outline is bevel.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 0
   */
  bevelOffset?: number;
  /**
   * How many bevel segments.
   *
   * @type {number}
   * @memberof Text3DProps
   * @default 4
   */
  bevelSegments?: number;
  /**
   * Whether to center the text.
   *
   * @type {boolean}
   * @memberof Text3DProps
   * @default false
   */
  center?: boolean;
  /**
   * Whether to update the text.
   *
   * @type {boolean}
   * @memberof Text3DProps
   * @default false
   */
  needUpdates?: boolean;
}
declare var __VLS_13$15: {};
type __VLS_Slots$32 = {} & {
  default?: (props: typeof __VLS_13$15) => any;
};
declare const __VLS_base$32: vue0.DefineComponent<Text3DProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<Text3DProps> & Readonly<{}>, {
  center: boolean;
  height: number;
  size: number;
  curveSegments: number;
  bevelEnabled: boolean;
  bevelThickness: number;
  bevelSize: number;
  bevelOffset: number;
  bevelSegments: number;
  needUpdates: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$65: __VLS_WithSlots$32<typeof __VLS_base$32, __VLS_Slots$32>;
declare const _default$75: typeof __VLS_export$65;
type __VLS_WithSlots$32<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/useAnimations.d.ts
/**
 * Creates an AnimationMixer and returns it.
 *
 * @export
 * @template T
 * @param {T[]} animations
 * @param {(Scene | Ref<Object3D | undefined | null>)} [modelRef]
 * @return {*}
 */
declare function useAnimations<T extends AnimationClip>(animations: MaybeRef<T[]>, modelRef?: MaybeRef<Object3D | undefined | null>, options?: {
  manualUpdate?: boolean;
}): {
  actions: vue0.ShallowReactive<{
    [key: string]: AnimationAction | undefined;
  }>;
  mixer: vue0.ComputedRef<AnimationMixer>;
};
//#endregion
//#region src/core/abstractions/Mask/useMask.d.ts
declare function useMask(id: Ref<number> | number, inverse?: Ref<boolean> | boolean): {
  stencilWrite: boolean;
  stencilRef: number;
  stencilFunc: 514 | 517;
  stencilFail: 7680;
  stencilZFail: 7680;
  stencilZPass: 7680;
};
//#endregion
//#region src/core/abstractions/useFBO/index.d.ts
interface FboOptions {
  width?: number;
  height?: number;
  depth?: boolean;
  settings?: RenderTargetOptions;
  /**
   * Whether to automatically render the FBO on the default scene.
   *
   *  @default true
   *  @type {boolean}
   *  @memberof FboProps
   */
  autoRender?: boolean;
}
declare function useFBO(options: FboOptions): Ref<WebGLRenderTarget<three5.Texture> | null, WebGLRenderTarget<three5.Texture> | null>;
//#endregion
//#region src/core/abstractions/useFBO/component.vue.d.ts
declare const __VLS_export$64: vue0.DefineComponent<FboOptions, {
  instance: vue0.Ref<three5.WebGLRenderTarget<three5.Texture> | null, three5.WebGLRenderTarget<three5.Texture> | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<FboOptions> & Readonly<{}>, {
  depth: boolean;
  settings: three5.RenderTargetOptions;
  autoRender: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$21: typeof __VLS_export$64;
//#endregion
//#region src/core/abstractions/useSurfaceSampler/index.d.ts
interface useSurfaceSamplerProps {
  transform?: TransformFn;
  weight?: string;
  count?: number;
  mesh?: Mesh;
  instanceMesh?: InstancedMesh | null;
}
interface SamplePayload {
  /**
   * The position of the sample.
   */
  position: Vector3;
  /**
   * The normal of the mesh at the sampled position.
   */
  normal: Vector3;
  /**
   * The vertex color of the mesh at the sampled position.
   */
  color: Color;
}
type TransformPayload = SamplePayload & {
  /**
   * The dummy object used to transform each instance.
   * This object's matrix will be updated after transforming & it will be used
   * to set the instance's matrix.
   */
  dummy: TresObject;
  /**
   * The mesh that's initially passed to the sampler.
   * Use this if you need to apply transforms from your mesh to your instances
   * or if you need to grab attributes from the geometry.
   */
  sampledMesh: Mesh;
};
type TransformFn = (payload: TransformPayload, i: number) => void;
declare const useSurfaceSampler: (mesh: Mesh, count?: number, instanceMesh?: InstancedMesh | null, weight?: string, transform?: TransformFn) => {
  buffer: vue0.Ref<{
    readonly isInterleavedBuffer: true;
    array: {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int8Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int8Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int8Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
      with: (index: number, value: number) => Int8Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int8Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint8Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint8Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint8Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint8Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint8ClampedArray<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint8ClampedArray<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
      with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint8ClampedArray";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int16Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int16Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int16Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
      with: (index: number, value: number) => Int16Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int16Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint16Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint16Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint16Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint16Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
      with: (index: number, value: number) => Int32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Float32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Float32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Float32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
      with: (index: number, value: number) => Float32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Float32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Float64Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Float64Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Float64Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
      with: (index: number, value: number) => Float64Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Float64Array";
    };
    stride: number;
    usage: three5.Usage;
    updateRanges: {
      start: number;
      count: number;
    }[];
    version: number;
    count: number;
    needsUpdate: boolean;
    uuid: string;
    onUploadCallback: () => void;
    onUpload: (callback: () => void) => InterleavedBuffer;
    set: (value: ArrayLike<number>, offset: number) => InterleavedBuffer;
    setUsage: (value: three5.Usage) => InterleavedBuffer;
    addUpdateRange: (start: number, count: number) => void;
    clearUpdateRanges: () => void;
    copy: (source: InterleavedBuffer) => InterleavedBuffer;
    copyAt: (index1: number, attribute: three5.InterleavedBufferAttribute, index2: number) => InterleavedBuffer;
    clone: (data: {}) => InterleavedBuffer;
    toJSON: (data: {}) => {
      uuid: string;
      buffer: string;
      type: string;
      stride: number;
    };
  }, InterleavedBuffer | {
    readonly isInterleavedBuffer: true;
    array: {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int8Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int8Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int8Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
      with: (index: number, value: number) => Int8Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int8Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint8Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint8Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint8Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint8Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint8ClampedArray<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint8ClampedArray<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
      with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint8ClampedArray";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int16Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int16Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int16Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
      with: (index: number, value: number) => Int16Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int16Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint16Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint16Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint16Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint16Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Int32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Int32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Int32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
      with: (index: number, value: number) => Int32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Int32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Uint32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Uint32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Uint32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
      with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Uint32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Float32Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Float32Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Float32Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
      with: (index: number, value: number) => Float32Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Float32Array";
    } | {
      [x: number]: number;
      readonly BYTES_PER_ELEMENT: number;
      readonly buffer: {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => ArrayBuffer;
        readonly maxByteLength: number;
        readonly resizable: boolean;
        resize: (newByteLength?: number) => void;
        readonly detached: boolean;
        transfer: (newByteLength?: number) => ArrayBuffer;
        transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
        readonly [Symbol.toStringTag]: string;
      } | {
        readonly byteLength: number;
        slice: (begin?: number, end?: number) => SharedArrayBuffer;
        readonly growable: boolean;
        readonly maxByteLength: number;
        grow: (newByteLength?: number) => void;
        readonly [Symbol.species]: SharedArrayBuffer;
        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
      };
      readonly byteLength: number;
      readonly byteOffset: number;
      copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
      every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
      filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
      find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
      findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
      forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
      indexOf: (searchElement: number, fromIndex?: number) => number;
      join: (separator?: string) => string;
      lastIndexOf: (searchElement: number, fromIndex?: number) => number;
      readonly length: number;
      map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
      reduce: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reduceRight: {
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
      };
      reverse: () => Float64Array<ArrayBufferLike>;
      set: (array: ArrayLike<number>, offset?: number) => void;
      slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
      some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
      sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
      subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
      toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
      };
      toString: () => string;
      valueOf: () => Float64Array<ArrayBufferLike>;
      entries: () => ArrayIterator<[number, number]>;
      keys: () => ArrayIterator<number>;
      values: () => ArrayIterator<number>;
      includes: (searchElement: number, fromIndex?: number) => boolean;
      at: (index: number) => number | undefined;
      findLast: {
        <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
        (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
      };
      findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
      toReversed: () => Float64Array<ArrayBuffer>;
      toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
      with: (index: number, value: number) => Float64Array<ArrayBuffer>;
      [Symbol.iterator]: () => ArrayIterator<number>;
      readonly [Symbol.toStringTag]: "Float64Array";
    };
    stride: number;
    usage: three5.Usage;
    updateRanges: {
      start: number;
      count: number;
    }[];
    version: number;
    count: number;
    needsUpdate: boolean;
    uuid: string;
    onUploadCallback: () => void;
    onUpload: (callback: () => void) => InterleavedBuffer;
    set: (value: ArrayLike<number>, offset: number) => InterleavedBuffer;
    setUsage: (value: three5.Usage) => InterleavedBuffer;
    addUpdateRange: (start: number, count: number) => void;
    clearUpdateRanges: () => void;
    copy: (source: InterleavedBuffer) => InterleavedBuffer;
    copyAt: (index1: number, attribute: three5.InterleavedBufferAttribute, index2: number) => InterleavedBuffer;
    clone: (data: {}) => InterleavedBuffer;
    toJSON: (data: {}) => {
      uuid: string;
      buffer: string;
      type: string;
      stride: number;
    };
  }>;
};
//#endregion
//#region src/core/abstractions/useSurfaceSampler/component.vue.d.ts
declare var __VLS_8$7: {};
type __VLS_Slots$31 = {} & {
  default?: (props: typeof __VLS_8$7) => any;
};
declare const __VLS_base$31: vue0.DefineComponent<useSurfaceSamplerProps, {
  samplerRef: vue0.Ref<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<useSurfaceSamplerProps> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$63: __VLS_WithSlots$31<typeof __VLS_base$31, __VLS_Slots$31>;
declare const _default$61: typeof __VLS_export$63;
type __VLS_WithSlots$31<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/ScreenSizer.vue.d.ts
declare var __VLS_15$1: {};
type __VLS_Slots$30 = {} & {
  default?: (props: typeof __VLS_15$1) => any;
};
declare const __VLS_base$30: vue0.DefineComponent<{}, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
declare const __VLS_export$62: __VLS_WithSlots$30<typeof __VLS_base$30, __VLS_Slots$30>;
declare const _default$63: typeof __VLS_export$62;
type __VLS_WithSlots$30<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/abstractions/Edges.vue.d.ts
interface EdgesProps {
  color?: TresColor;
  threshold?: number;
}
declare var __VLS_8$6: {};
type __VLS_Slots$29 = {} & {
  default?: (props: typeof __VLS_8$6) => any;
};
declare const __VLS_base$29: vue0.DefineComponent<EdgesProps, {
  instance: vue0.ShallowRef<LineSegments<BufferGeometry<three5.NormalBufferAttributes, three5.BufferGeometryEventMap>, three5.Material | three5.Material[], three5.Object3DEventMap> | undefined, LineSegments<BufferGeometry<three5.NormalBufferAttributes, three5.BufferGeometryEventMap>, three5.Material | three5.Material[], three5.Object3DEventMap> | undefined>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<EdgesProps> & Readonly<{}>, {
  color: TresColor;
  threshold: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$61: __VLS_WithSlots$29<typeof __VLS_base$29, __VLS_Slots$29>;
declare const _default$18: typeof __VLS_export$61;
type __VLS_WithSlots$29<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/useEnvironment/const.d.ts
interface EnvironmentOptions {
  /**
   * If true, the environment will be set as the scene's background.
   *
   * @type {boolean}
   * @default false
   */
  background?: boolean | string;
  /**
   * The blur radius of the environment.
   *
   * @type {number}
   * @default 0
   */
  blur?: number;
  /**
   * The files to load. If a string is provided, it will be loaded as an equirectangular texture.
   * If an array is provided, it will be loaded as a cube texture.
   *
   * @type {(string | string[])}
   */
  files?: string | string[];
  /**
   * The path to the files.
   *
   * @type {string}
   * @default '/'
   */
  path?: string;
  /**
   * The preset to use. If provided, the files and path props will be ignored.
   *
   * @type {EnvironmentPresetsType}
   */
  preset?: EnvironmentPresetsType;
  /**
   * The resolution of the WebGLCubeRenderTarget.
   *
   * @type {number}
   * @default 256
   */
  resolution?: number;
  /**
   * The near of the CubeCamera.
   *
   * @type {number}
   * @default 1
   */
  near?: number;
  /**
   * The far of the CubeCamera.
   *
   * @type {number}
   * @default 1000
   */
  far?: number;
  /**
   * The frames of the cubeCamera.update.
   *
   * @type {number}
   * @default Infinity
   */
  frames?: number;
  /**
   * The intensity of the background.
   *
   * @type {number}
   * @default 1
   */
  backgroundIntensity?: number;
  /**
   * The rotation of the background.
   *
   * @type {VectorFlexibleParams}
   * @default [0, 0, 0]
   */
  backgroundRotation?: VectorFlexibleParams;
  /**
   * The intensity of the environment.
   *
   * @type {number}
   * @default 1
   */
  environmentIntensity?: number;
  /**
   * The rotation of the environment.
   *
   * @type {VectorFlexibleParams}
   * @default [0, 0, 0]
   */
  environmentRotation?: VectorFlexibleParams;
  /**
   * If true, the environment rotation will be synced with the background rotation.
   * This means when backgroundRotation changes, environmentRotation will be updated to match.
   *
   * @type {boolean}
   * @default false
   */
  syncMaterials?: boolean;
}
declare const environmentPresets: {
  sunset: string;
  studio: string;
  city: string;
  umbrellas: string;
  night: string;
  forest: string;
  snow: string;
  dawn: string;
  hangar: string;
  urban: string;
  modern: string;
  shangai: string;
};
type EnvironmentPresetsType = keyof typeof environmentPresets;
//#endregion
//#region src/core/staging/useEnvironment/index.d.ts
/**
 * Component that loads an environment map and sets it as the scene's background and environment.
 *
 * @export
 * @param {Partial<EnvironmentOptions>} options - The options for the environment map
 *   files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],
 *   blur = 0,
 *   background = false,
 *   path = undefined,
 *   preset = undefined,
 *   colorSpace = 'srgb',
 *   backgroundIntensity = 1,
 *   environmentIntensity = 1,
 *   backgroundRotation = [0, 0, 0],
 *   environmentRotation = [0, 0, 0],
 *   syncMaterials = false,
 * @param {Ref<WebGLCubeRenderTarget | null>} fbo - The framebuffer object
 * @return {Promise<Ref<Texture | CubeTexture | null>>} The loaded texture
 */
declare function useEnvironment(options: Partial<EnvironmentOptions>, fbo: Ref<WebGLCubeRenderTarget | null>): Promise<Ref<Texture | CubeTexture | null>>;
//#endregion
//#region src/core/controls/CameraControls.vue.d.ts
interface CameraControlsProps {
  /**
   * Whether to make this the default controls.
   *
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  makeDefault?: boolean;
  /**
   * The camera to control.
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof CameraControlsProps
   */
  camera?: PerspectiveCamera | OrthographicCamera;
  /**
   * The dom element to listen to.
   *
   * @type {HTMLElement}
   * @memberof CameraControlsProps
   */
  domElement?: HTMLElement;
  /**
   * Minimum vertical angle in radians.
   * The angle has to be between `0` and `.maxPolarAngle` inclusive.
   *
   * @default 0
   * @type {number}
   * @memberof CameraControlsProps
   */
  minPolarAngle?: number;
  /**
   * Maximum vertical angle in radians.
   * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
   *
   * @default Math.PI
   * @type {number}
   * @memberof CameraControlsProps
   */
  maxPolarAngle?: number;
  /**
   * Minimum horizontal angle in radians.
   * The angle has to be less than `.maxAzimuthAngle`.
   *
   * @default -Infinity
   * @type {number}
   * @memberof CameraControlsProps
   */
  minAzimuthAngle?: number;
  /**
   * Maximum horizontal angle in radians.
   * The angle has to be greater than `.minAzimuthAngle`.
   *
   * @default Infinity
   * @type {number}
   * @memberof CameraControlsProps
   */
  maxAzimuthAngle?: number;
  /**
   * Current disatnce.
   *
   * @type {number}
   * @memberof CameraControlsProps
   */
  distance?: number;
  /**
   * Minimum distance for dolly. The value must be higher than `0`.
   * PerspectiveCamera only.
   *
   * @default Number.EPSILON
   * @type {number}
   * @memberof CameraControlsProps
   */
  minDistance?: number;
  /**
   * Maximum distance for dolly. The value must be higher than `minDistance`.
   * PerspectiveCamera only.
   *
   * @default Infinity
   * @type {number}
   * @memberof CameraControlsProps
   */
  maxDistance?: number;
  /**
   * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`.
   * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`),
   * `infinityDolly` will keep the distance and pushes the target position instead.
   *
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  infinityDolly?: boolean;
  /**
   * Minimum camera zoom.
   *
   * @default 0.01
   * @type {number}
   * @memberof CameraControlsProps
   */
  minZoom?: number;
  /**
   * Maximum camera zoom.
   *
   * @default Infinity
   * @type {number}
   * @memberof CameraControlsProps
   */
  maxZoom?: number;
  /**
   * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
   *
   * @default 0.25
   * @type {number}
   * @memberof CameraControlsProps
   */
  smoothTime?: number;
  /**
   * The smoothTime while dragging.
   *
   * @default 0.125
   * @type {number}
   * @memberof CameraControlsProps
   */
  draggingSmoothTime?: number;
  /**
   * Max transition speed in unit-per-seconds.
   *
   * @default Infinity
   * @type {number}
   * @memberof CameraControlsProps
   */
  maxSpeed?: number;
  /**
   * Speed of azimuth (horizontal) rotation.
   *
   * @default 1.0
   * @type {number}
   * @memberof CameraControlsProps
   */
  azimuthRotateSpeed?: number;
  /**
   * Speed of polar (vertical) rotation.
   *
   * @default 1.0
   * @type {number}
   * @memberof CameraControlsProps
   */
  polarRotateSpeed?: number;
  /**
   * Speed of mouse-wheel dollying.
   *
   * @default 1.0
   * @type {number}
   * @memberof CameraControlsProps
   */
  dollySpeed?: number;
  /**
   * `true` to invert direction when dollying or zooming via drag.
   *
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  dollyDragInverted?: boolean;
  /**
   * Speed of drag for truck and pedestal.
   *
   * @default 2.0
   * @type {number}
   * @memberof CameraControlsProps
   */
  truckSpeed?: number;
  /**
   * `true` to enable Dolly-in to the mouse cursor coords.
   *
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  dollyToCursor?: boolean;
  /**
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  dragToOffset?: boolean;
  /**
   * The same as `.screenSpacePanning` in three.js's OrbitControls.
   *
   * @default false
   * @type {boolean}
   * @memberof CameraControlsProps
   */
  verticalDragToForward?: boolean;
  /**
   * Friction ratio of the boundary.
   *
   * @default 0.0
   * @type {number}
   * @memberof CameraControlsProps
   */
  boundaryFriction?: number;
  /**
   * Controls how soon the `rest` event fires as the camera slows.
   *
   * @default 0.01
   * @type {number}
   * @memberof CameraControlsProps
   */
  restThreshold?: number;
  /**
   * An array of Meshes to collide with the camera.
   * Be aware colliderMeshes may decrease performance.
   * The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
   *
   * @default []
   * @type {Object3D[]}
   * @memberof CameraControlsProps
   */
  colliderMeshes?: Object3D[];
  /**
   * User's mouse input config.
   *
   * | Button to assign        | Options                                                        | Default                                                         |
   * | ----------------------- | -------------------------------------------------------------- | --------------------------------------------------------------- |
   * | `mouseButtons.left`     | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `ROTATE`                                                        |
   * | `mouseButtons.right`    | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `TRUCK`                                                         |
   * | `mouseButtons.wheel`   | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `DOLLY` for Perspective camera, `ZOOM` for Orthographic camera. |
   * | `mouseButtons.middle`  | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `DOLLY`                                                         |
   *
   * 1. Mouse wheel event for scroll "up/down", on mac "up/down/left/right".
   * 2. Mouse wheel "button" click event.
   *
   * > **_NOTE:_** `DOLLY` can't be set when camera is Orthographic.
   *
   * @default See description
   * @memberof CameraControlsProps
   */
  mouseButtons?: Partial<CameraControls['mouseButtons']>;
  /**
   * User's touch input config.
   *
   * | Fingers to assign | Options                                                                                                                                                                                                                                 | Default                                                                                |
   * | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
   * | `touches.one`     | `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE`                                                                                                                                                        | `TOUCH_ROTATE`                                                                         |
   * | `touches.two`     | `TOUCH_DOLLY_TRUCK` \| `TOUCH_DOLLY_OFFSET` \| `TOUCH_DOLLY_ROTATE` \| `TOUCH_ZOOM_TRUCK` \| `TOUCH_ZOOM_OFFSET` \| `TOUCH_ZOOM_ROTATE` \| `TOUCH_DOLLY` \| `TOUCH_ZOOM` \| `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `NONE` | `TOUCH_DOLLY_TRUCK` for Perspective camera, `TOUCH_ZOOM_TRUCK` for Othographic camera. |
   * | `touches.three`   | `TOUCH_DOLLY_TRUCK` \| `TOUCH_DOLLY_OFFSET` \| `TOUCH_DOLLY_ROTATE` \| `TOUCH_ZOOM_TRUCK` \| `TOUCH_ZOOM_OFFSET` \| `TOUCH_ZOOM_ROTATE` \| `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `NONE`                                  | `TOUCH_TRUCK`                                                                          |
   *
   * > **_NOTE:_** `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY` can't be set when camera is Orthographic.
   *
   * @default See description
   * @memberof CameraControlsProps
   */
  touches?: Partial<CameraControls['touches']>;
}
declare const __VLS_export$60: vue0.DefineComponent<CameraControlsProps, {
  instance: vue0.ShallowRef<(three5.EventDispatcher<{}> & {
    enabled: boolean;
  } & CameraControls) | null, (three5.EventDispatcher<{}> & {
    enabled: boolean;
  } & CameraControls) | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  start: (...args: any[]) => void;
  end: (...args: any[]) => void;
  change: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<CameraControlsProps> & Readonly<{
  onStart?: ((...args: any[]) => any) | undefined;
  onEnd?: ((...args: any[]) => any) | undefined;
  onChange?: ((...args: any[]) => any) | undefined;
}>, {
  distance: number;
  makeDefault: boolean;
  minPolarAngle: number;
  maxPolarAngle: number;
  minAzimuthAngle: number;
  maxAzimuthAngle: number;
  minDistance: number;
  maxDistance: number;
  infinityDolly: boolean;
  minZoom: number;
  maxZoom: number;
  smoothTime: number;
  draggingSmoothTime: number;
  maxSpeed: number;
  azimuthRotateSpeed: number;
  polarRotateSpeed: number;
  dollySpeed: number;
  dollyDragInverted: boolean;
  truckSpeed: number;
  dollyToCursor: boolean;
  dragToOffset: boolean;
  verticalDragToForward: boolean;
  boundaryFriction: number;
  restThreshold: number;
  colliderMeshes: Object3D[];
  mouseButtons: Partial<CameraControls["mouseButtons"]>;
  touches: Partial<CameraControls["touches"]>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$7: typeof __VLS_export$60;
//#endregion
//#region src/core/controls/Helper/component.vue.d.ts
type HelperConstructor = new (...args: any[]) => any;
interface HelperProps {
  type: HelperConstructor;
  args?: any[];
}
declare const __VLS_export$59: vue0.DefineComponent<HelperProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<HelperProps> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$26: typeof __VLS_export$59;
//#endregion
//#region src/core/controls/KeyboardControls.vue.d.ts
interface KeyboardControlsProps {
  /**
   * Whether to make this the default controls.
   *
   * @default true
   * @type {boolean}
   * @memberof KeyboardControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  makeDefault?: boolean;
  /**
   * The camera to control.
   *
   * @default false
   * @type {boolean}
   * @memberof KeyboardControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  camera?: Camera;
  /**
   * The dom element to listen to.
   *
   * @type {HTMLElement}
   * @memberof KeyboardControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  domElement?: HTMLElement;
  /**
   * Indicates the movement speed.
   * @type {number}
   * @default 0.2
   * @memberof KeyboardControlsProps
   *
   */
  moveSpeed?: number;
  /**
   * The trigger id.
   *
   * @type {string}
   * @memberof KeyboardControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  selector?: string;
}
declare const __VLS_export$58: vue0.DefineComponent<KeyboardControlsProps, {
  instance: vue0.Ref<_tresjs_core0.TresControl | null, _tresjs_core0.TresControl | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  change: (...args: any[]) => void;
  isLock: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<KeyboardControlsProps> & Readonly<{
  onChange?: ((...args: any[]) => any) | undefined;
  onIsLock?: ((...args: any[]) => any) | undefined;
}>, {
  makeDefault: boolean;
  moveSpeed: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$31: typeof __VLS_export$58;
//#endregion
//#region src/core/controls/MapControls.vue.d.ts
interface MapControlsProps {
  /**
   * Whether to make this the default controls.
   *
   * @default false
   * @type {boolean}
   * @memberof MapControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/MapControls
   */
  makeDefault?: boolean;
  /**
   * The camera to control.
   *
   * @type {Camera}
   * @memberof MapControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/MapControls
   */
  camera?: Camera;
  /**
   * The dom element to listen to.
   *
   * @type {HTMLElement}
   * @memberof MapControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/MapControls
   */
  domElement?: HTMLElement;
  /**
   * The target to orbit around.
   *
   * @type {TresVector3}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.target
   */
  target?: TresVector3;
  /**
   * Whether to enable damping (inertia)
   *
   * @default false
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableDamping
   */
  enableDamping?: boolean;
  /**
   * The damping inertia used if `.enableDamping` is set to true
   *
   * @default 0.05
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor
   */
  dampingFactor?: number;
  /**
   * Set to true to automatically rotate around the target.
   *
   * @default false
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotate
   */
  autoRotate?: boolean;
  /**
   * How fast to rotate around the target if `.autoRotate` is true.
   *
   * @default 2
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotateSpeed
   */
  autoRotateSpeed?: number;
  /**
   * Whether to enable panning.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enablePan
   */
  enablePan?: boolean;
  /**
   * How fast to pan the camera when the keyboard is used. Default is 7.0 pixels per keypress.
   *
   * @default 7.0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keyPanSpeed
   */
  keyPanSpeed?: number;
  /**
   * This object contains references to the keycodes for controlling camera panning.
   * Default is the 4 arrow keys.
   *
   * @default `{ LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }`
   * @type Record<string, string>
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keys
   */
  keys?: Record<string, string>;
  /**
   * How far you can orbit horizontally, upper limit.
   * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
   * with ( max - min < 2 PI ). Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxAzimuthAngle
   */
  maxAzimuthAngle?: number;
  /**
   * How far you can orbit horizontally, lower limit.
   * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
   * with ( max - min < 2 PI ).
   * Default is - Infinity.
   *
   * @default -Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minAzimuthAngle
   */
  minAzimuthAngle?: number;
  /**
   * How far you can orbit vertically, upper limit.
   * Range is 0 to Math.PI radians, and default is Math.PI.
   *
   * @default Math.PI
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxPolarAngle
   */
  maxPolarAngle?: number;
  /**
   * How far you can orbit vertically, lower limit.
   * Range is 0 to Math.PI radians, and default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minPolarAngle
   */
  minPolarAngle?: number;
  /**
   * The minimum distance of the camera to the target.
   * Default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minDistance
   */
  minDistance?: number;
  /**
   * The maximum distance of the camera to the target.
   * Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxDistance
   */
  maxDistance?: number;
  /**
   * The minimum field of view angle, in radians.
   * Default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minZoom
   */
  minZoom?: number;
  /**
   * The maximum field of view angle, in radians.
   * ( OrthographicCamera only ).
   * Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxZoom
   */
  maxZoom?: number;
  touches?: {
    ONE?: number | undefined;
    TWO?: number | undefined;
  };
  /**
   * Whether to enable zooming.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableZoom
   */
  enableZoom?: boolean;
  /**
   * How fast to zoom in and out. Default is 1.
   *
   * @default 1
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.zoomSpeed
   */
  zoomSpeed?: number;
  /**
   * Whether to enable rotating.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableRotate
   */
  enableRotate?: boolean;
  /**
   * How fast to rotate around the target. Default is 1.
   *
   * @default 1
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.rotateSpeed
   */
  rotateSpeed?: number;
}
declare const __VLS_export$57: vue0.DefineComponent<MapControlsProps, {
  instance: vue0.ShallowRef<MapControls | null, MapControls | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  start: (...args: any[]) => void;
  end: (...args: any[]) => void;
  change: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<MapControlsProps> & Readonly<{
  onStart?: ((...args: any[]) => any) | undefined;
  onEnd?: ((...args: any[]) => any) | undefined;
  onChange?: ((...args: any[]) => any) | undefined;
}>, {
  makeDefault: boolean;
  minPolarAngle: number;
  maxPolarAngle: number;
  minAzimuthAngle: number;
  maxAzimuthAngle: number;
  minDistance: number;
  maxDistance: number;
  minZoom: number;
  maxZoom: number;
  enableDamping: boolean;
  dampingFactor: number;
  autoRotate: boolean;
  autoRotateSpeed: number;
  enablePan: boolean;
  keyPanSpeed: number;
  enableZoom: boolean;
  zoomSpeed: number;
  enableRotate: boolean;
  rotateSpeed: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$37: typeof __VLS_export$57;
//#endregion
//#region src/core/controls/OrbitControls.vue.d.ts
interface OrbitControlsProps {
  /**
   * Whether to make this the default controls.
   *
   * @default false
   * @type {boolean}
   * @memberof OrbitControlsProps
   */
  makeDefault?: boolean;
  /**
   * The camera to control.
   *
   * @type {Camera}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.camera
   */
  camera?: Camera;
  /**
   * The dom element to listen to.
   *
   * @type {HTMLElement}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.domElement
   */
  domElement?: HTMLElement;
  /**
   * The target to orbit around.
   *
   * @type {TresVector3}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.target
   */
  target?: TresVector3;
  /**
   * Whether to enable damping (inertia)
   *
   * @default false
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableDamping
   */
  enableDamping?: boolean;
  /**
   * The damping inertia used if `.enableDamping` is set to true
   *
   * @default 0.05
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor
   */
  dampingFactor?: number;
  /**
   * Set to true to automatically rotate around the target.
   *
   * @default false
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotate
   */
  autoRotate?: boolean;
  /**
   * How fast to rotate around the target if `.autoRotate` is true.
   *
   * @default 2
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotateSpeed
   */
  autoRotateSpeed?: number;
  /**
   * Whether to enable panning.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enablePan
   */
  enablePan?: boolean;
  /**
   * How fast to pan the camera when the keyboard is used. Default is 7.0 pixels per keypress.
   *
   * @default 7.0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keyPanSpeed
   */
  keyPanSpeed?: number;
  /**
   * This object contains references to the keycodes for controlling camera panning.
   * Default is the 4 arrow keys.
   *
   * @default `{ LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }`
   * @type Record<string, string>
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keys
   */
  keys?: Record<string, string>;
  /**
   * How far you can orbit horizontally, upper limit.
   * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
   * with ( max - min < 2 PI ). Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxAzimuthAngle
   */
  maxAzimuthAngle?: number;
  /**
   * How far you can orbit horizontally, lower limit.
   * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
   * with ( max - min < 2 PI ).
   * Default is - Infinity.
   *
   * @default -Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minAzimuthAngle
   */
  minAzimuthAngle?: number;
  /**
   * How far you can orbit vertically, upper limit.
   * Range is 0 to Math.PI radians, and default is Math.PI.
   *
   * @default Math.PI
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxPolarAngle
   */
  maxPolarAngle?: number;
  /**
   * How far you can orbit vertically, lower limit.
   * Range is 0 to Math.PI radians, and default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minPolarAngle
   */
  minPolarAngle?: number;
  /**
   * The minimum distance of the camera to the target.
   * Default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minDistance
   */
  minDistance?: number;
  /**
   * The maximum distance of the camera to the target.
   * Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxDistance
   */
  maxDistance?: number;
  /**
   * The minimum field of view angle, in radians.
   * Default is 0.
   *
   * @default 0
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minZoom
   */
  minZoom?: number;
  /**
   * The maximum field of view angle, in radians.
   * ( OrthographicCamera only ).
   * Default is Infinity.
   *
   * @default Infinity
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxZoom
   */
  maxZoom?: number;
  touches?: {
    ONE?: number | undefined;
    TWO?: number | undefined;
  };
  /**
   * Whether to enable zooming.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableZoom
   */
  enableZoom?: boolean;
  /**
   * How fast to zoom in and out. Default is 1.
   *
   * @default 1
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.zoomSpeed
   */
  zoomSpeed?: number;
  /**
   * Whether to enable rotating.
   *
   * @default true
   * @type {boolean}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableRotate
   */
  enableRotate?: boolean;
  /**
   * How fast to rotate around the target. Default is 1.
   *
   * @default 1
   * @type {number}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.rotateSpeed
   */
  rotateSpeed?: number;
  /**
   * This object contains references to the mouse actions used by the controls.
   * LEFT: Rotate around the target
   * MIDDLE: Zoom the camera
   * RIGHT: Pan the camera
   *
   * @default { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN }
   * @type {{ LEFT?: number, MIDDLE?: number, RIGHT?: number }}
   * @memberof OrbitControlsProps
   * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.mouseButtons
   */
  mouseButtons?: {
    LEFT?: number;
    MIDDLE?: number;
    RIGHT?: number;
  };
}
declare const __VLS_export$56: vue0.DefineComponent<OrbitControlsProps, {
  instance: vue0.ShallowRef<OrbitControls | null, OrbitControls | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  start: (...args: any[]) => void;
  end: (...args: any[]) => void;
  change: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<OrbitControlsProps> & Readonly<{
  onStart?: ((...args: any[]) => any) | undefined;
  onEnd?: ((...args: any[]) => any) | undefined;
  onChange?: ((...args: any[]) => any) | undefined;
}>, {
  makeDefault: boolean;
  minPolarAngle: number;
  maxPolarAngle: number;
  minAzimuthAngle: number;
  maxAzimuthAngle: number;
  minDistance: number;
  maxDistance: number;
  minZoom: number;
  maxZoom: number;
  mouseButtons: {
    LEFT?: number;
    MIDDLE?: number;
    RIGHT?: number;
  };
  touches: {
    ONE?: number | undefined;
    TWO?: number | undefined;
  };
  target: TresVector3;
  enableDamping: boolean;
  dampingFactor: number;
  autoRotate: boolean;
  autoRotateSpeed: number;
  enablePan: boolean;
  keyPanSpeed: number;
  enableZoom: boolean;
  zoomSpeed: number;
  enableRotate: boolean;
  rotateSpeed: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$49: typeof __VLS_export$56;
//#endregion
//#region src/core/controls/PointerLockControls.vue.d.ts
interface PointerLockControlsProps {
  /**
   * Whether to make this the default controls.
   *
   * @default false
   * @type {boolean}
   * @memberof PointerLockControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  makeDefault?: boolean;
  /**
   * The camera to control.
   *
   * @default false
   * @type {boolean}
   * @memberof PointerLockControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  camera?: Camera;
  /**
   * The dom element to listen to.
   *
   * @type {HTMLElement}
   * @memberof PointerLockControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  domElement?: HTMLElement;
  /**
   * The trigger id.
   *
   * @type {string}
   * @memberof PointerLockControlsProps
   * @see https://threejs.org/docs/index.html?q=pointe#examples/en/controls/PointerLockControls
   */
  selector?: string;
}
declare const __VLS_export$55: vue0.DefineComponent<PointerLockControlsProps, {
  instance: vue0.Ref<_tresjs_core0.TresControl | null, _tresjs_core0.TresControl | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  change: (...args: any[]) => void;
  isLock: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<PointerLockControlsProps> & Readonly<{
  onChange?: ((...args: any[]) => any) | undefined;
  onIsLock?: ((...args: any[]) => any) | undefined;
}>, {
  makeDefault: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$53: typeof __VLS_export$55;
//#endregion
//#region src/core/controls/ScrollControls.vue.d.ts
type __VLS_Props$5 = {
  pages?: number;
  distance?: number;
  smoothScroll?: number;
  horizontal?: boolean;
  htmlScroll?: boolean;
};
declare var __VLS_8$5: {};
type __VLS_Slots$28 = {} & {
  default?: (props: typeof __VLS_8$5) => any;
};
declare const __VLS_base$28: vue0.DefineComponent<__VLS_Props$5, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  "update:modelValue": (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<__VLS_Props$5> & Readonly<{
  "onUpdate:modelValue"?: ((...args: any[]) => any) | undefined;
}>, {
  distance: number;
  pages: number;
  smoothScroll: number;
  horizontal: boolean;
  htmlScroll: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$54: __VLS_WithSlots$28<typeof __VLS_base$28, __VLS_Slots$28>;
declare const _default$65: typeof __VLS_export$54;
type __VLS_WithSlots$28<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/controls/TransformControls.vue.d.ts
interface TransformControlsProps {
  object: Object3D;
  camera?: Camera;
  mode?: string;
  enabled?: boolean;
  axis?: 'X' | 'Y' | 'Z' | 'XY' | 'YZ' | 'XZ' | 'XYZ';
  translationSnap?: number;
  rotationSnap?: number;
  scaleSnap?: number;
  space?: 'local' | 'world';
  size?: number;
  showX?: boolean;
  showY?: boolean;
  showZ?: boolean;
}
declare const __VLS_export$53: vue0.DefineComponent<TransformControlsProps, {
  instance: vue0.ShallowRef<TransformControls<Camera> | null, TransformControls<Camera> | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  dragging: (...args: any[]) => void;
  change: (...args: any[]) => void;
  mouseDown: (...args: any[]) => void;
  mouseUp: (...args: any[]) => void;
  objectChange: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<TransformControlsProps> & Readonly<{
  onDragging?: ((...args: any[]) => any) | undefined;
  onChange?: ((...args: any[]) => any) | undefined;
  onMouseDown?: ((...args: any[]) => any) | undefined;
  onMouseUp?: ((...args: any[]) => any) | undefined;
  onObjectChange?: ((...args: any[]) => any) | undefined;
}>, {
  size: number;
  mode: string;
  enabled: boolean;
  axis: "X" | "Y" | "Z" | "XY" | "YZ" | "XZ" | "XYZ";
  space: "local" | "world";
  showX: boolean;
  showY: boolean;
  showZ: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$78: typeof __VLS_export$53;
//#endregion
//#region src/core/loaders/useSVG/index.d.ts
interface UseSVGOptions {
  /**
   * Whether to skip rendering strokes
   * @type {boolean}
   * @default false
   */
  skipStrokes?: boolean;
  /**
   * Whether to skip rendering fills
   * @type {boolean}
   * @default false
   */
  skipFills?: boolean;
  /**
   * Fill material properties
   * @type {MeshBasicMaterialParameters}
   */
  fillMaterial?: MeshBasicMaterialParameters;
  /**
   * Stroke material properties
   * @type {MeshBasicMaterialParameters}
   */
  strokeMaterial?: MeshBasicMaterialParameters;
  /**
   * Depth type - how should the resulting meshes be rendered?
   * 'renderOrder' disables depthWrite and sets renderOrder of each layer
   * 'flat' disables depthWrite on materials
   * 'offsetZ' enables depthWrite and inserts small distance between layers
   * number is treated same as 'offsetZ' using the number as distance
   * @type {'renderOrder' | 'flat' | 'offsetZ' | number}
   * @default 'renderOrder'
   */
  depth?: 'renderOrder' | 'flat' | 'offsetZ' | number;
}
interface SVGLayer {
  geometry: BufferGeometry;
  material: MeshBasicMaterialParameters;
  isStroke: boolean;
}
/**
 * Vue composable for loading SVG files in TresJS
 *
 * @remarks
 * This composable uses Three.js SVGLoader under the hood to load and process SVG files
 * into geometries and materials that can be rendered in a 3D scene.
 *
 * @example
 * ```ts
 * const { state: svg, layers } = useSVG('/path/to/file.svg', { skipStrokes: false })
 * ```
 *
 * @param {MaybeRef<string>} path - Path to the SVG file or SVG data string
 * @param {UseSVGOptions} options - Options for processing the SVG
 * @returns Object containing the SVG state, loading state, processed layers and disposal function
 */
declare function useSVG(path: MaybeRef<string>, options?: UseSVGOptions): {
  state: Ref<SVGResult | null>;
  isLoading: Ref<boolean>;
  execute: (delay?: number, ...args: any[]) => Promise<SVGResult>;
  layers: ComputedRef<SVGLayer[]>;
  dispose: () => void;
};
//#endregion
//#region src/core/loaders/useSVG/component.vue.d.ts
interface SVGProps {
  /**
   *
   * The SVG data or path to an SVG file
   *
   * @type {string}
   * @required
   * @memberof SVGProps
   *
   */
  src: string;
  /**
   *
   * Whether to draw strokes
   *
   * @type {boolean}
   * @default false
   * @memberof SVGProps
   *
   */
  skipStrokes?: boolean;
  /**
   *
   * Whether to draw fills
   *
   * @type {boolean}
   * @default false
   * @memberof SVGProps
   *
   */
  skipFills?: boolean;
  /**
   *
   * Fill material properties
   *
   * @type {MeshBasicMaterialParameters}
   * @default undefined
   * @memberof SVGProps
   *
   */
  fillMaterial?: MeshBasicMaterialParameters;
  /**
   *
   * Stroke material properties
   *
   * @type {MeshBasicMaterialParameters}
   * @default undefined
   * @memberof SVGProps
   *
   */
  strokeMaterial?: MeshBasicMaterialParameters;
  /**
   *
   * Fill Mesh properties
   *
   * @type {TresOptions}
   * @default undefined
   * @memberof SVGProps
   *
   */
  fillMeshProps?: TresOptions;
  /**
   *
   * Stroke Mesh properties
   *
   * @type {TresOptions}
   * @default undefined
   * @memberof SVGProps
   *
   */
  strokeMeshProps?: TresOptions;
  /**
   *
   * Depth type
   * How should the resulting meshes and materials be rendered?
   * 'renderOrder' disables `depthWrite` and sets the `renderOrder` of each layer.
   * 'flat' disables `depthWrite` on materials.
   * 'offsetZ' enables `depthWrite` and inserts a small distance between each layer on the z-axis to avoid z-fighting.
   * number is treated the same as 'offsetZ'; the number is used as the distance between layers
   *
   * depthWrite documentation: https://threejs.org/docs/#api/en/materials/Material.depthWrite
   * renderOrder documentation: https://threejs.org/docs/?q=mesh#api/en/core/Object3D.renderOrder
   *
   * @type { 'renderOrder' | 'flat' | 'offsetZ' | number }
   * @default 'renderOrder'
   * @memberof SVGProps
   *
   */
  depth?: 'renderOrder' | 'flat' | 'offsetZ' | number;
}
declare const __VLS_export$52: vue0.DefineComponent<SVGProps, {
  instance: vue0.Ref<three_stdlib0.SVGResult | null, three_stdlib0.SVGResult | null>;
  layers: vue0.ComputedRef<SVGLayer[]>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SVGProps> & Readonly<{}>, {
  depth: "renderOrder" | "flat" | "offsetZ" | number;
  skipStrokes: boolean;
  skipFills: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$80: typeof __VLS_export$52;
//#endregion
//#region src/core/loaders/useFBX/component.vue.d.ts
interface FBXModelProps {
  /**
   * Path to the FBX file.
   *
   * @type {string}
   * @memberof FBXModelProps
   * @required
   */
  path: string;
  /**
   *
   * Whether to use cast-shadow to the model.
   *
   * @type {boolean}
   * @default false
   * @memberof FBXModelProps
   *
   */
  castShadow?: boolean;
  /**
   *
   * Whether to use receive-shadow to the model.
   *
   * @type {boolean}
   * @default false
   * @memberof FBXModelProps
   *
   */
  receiveShadow?: boolean;
}
declare const __VLS_export$51: vue0.DefineComponent<FBXModelProps, {
  instance: vue0.Ref<Group<three5.Object3DEventMap> | null, Group<three5.Object3DEventMap> | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<FBXModelProps> & Readonly<{}>, {
  castShadow: boolean;
  receiveShadow: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$20: typeof __VLS_export$51;
//#endregion
//#region src/core/loaders/useGLTF/component.vue.d.ts
interface GLTFModelProps {
  /**
   *
   * The path to the GLTF file.
   *
   * @type {string}
   * @required
   * @memberof GLTFModelProps
   *
   */
  path: string;
  /**
   *
   * Whether to use Draco compression.
   *
   * @type {boolean}
   * @default false
   * @memberof GLTFModelProps
   *
   */
  draco?: boolean;
  /**
   *
   * Whether to use cast-shadow to the model.
   *
   * @type {boolean}
   * @default false
   * @memberof GLTFModelProps
   *
   */
  castShadow?: boolean;
  /**
   *
   * Whether to use receive-shadow to the model.
   *
   * @type {boolean}
   * @default false
   * @memberof GLTFModelProps
   *
   */
  receiveShadow?: boolean;
  /**
   *
   * The path to the Draco decoder.
   *
   * @type {string}
   * @default 'https://www.gstatic.com/draco/versioned/decoders/1.4.1/'
   * @memberof GLTFModelProps
   *
   */
  decoderPath?: string;
}
declare const __VLS_export$50: vue0.DefineComponent<GLTFModelProps, {
  instance: vue0.Ref<three_stdlib0.GLTF | null, three_stdlib0.GLTF | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<GLTFModelProps> & Readonly<{}>, {
  castShadow: boolean;
  receiveShadow: boolean;
  draco: boolean;
  decoderPath: string;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$23: typeof __VLS_export$50;
//#endregion
//#region src/core/loaders/useTexture/component.vue.d.ts
type __VLS_Props$4 = {
  /**
   * The path to the texture file.
   *
   * @type {string}
   * @required
   * @memberof TextureProps
   */
  path: string;
  /**
   * Optional THREE.js LoadingManager
   */
  manager?: LoadingManager;
};
declare var __VLS_1: {
  state: {
    readonly isTexture: true;
    readonly id: number;
    uuid: string;
    name: string;
    source: {
      readonly isSource: true;
      readonly id: number;
      uuid: string;
      data: any;
      dataReady: boolean;
      version: number;
      getSize: (target: three5.Vector3) => three5.Vector3;
      needsUpdate: boolean;
      toJSON: (meta?: string | {}) => three5.SourceJSON;
    };
    readonly width: number;
    readonly height: number;
    readonly depth: number;
    image: any;
    mipmaps: HTMLCanvasElement[] | {
      data: {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Int8Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Int8Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Int8Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
        with: (index: number, value: number) => Int8Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Int8Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Uint8Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Uint8Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Uint8Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
        with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Uint8Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Uint8ClampedArray<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Uint8ClampedArray<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
        with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Uint8ClampedArray";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Int16Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Int16Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Int16Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
        with: (index: number, value: number) => Int16Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Int16Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Uint16Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Uint16Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Uint16Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
        with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Uint16Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Int32Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Int32Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Int32Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
        with: (index: number, value: number) => Int32Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Int32Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Uint32Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Uint32Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Uint32Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
        with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Uint32Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Float32Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Float32Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Float32Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
        with: (index: number, value: number) => Float32Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Float32Array";
      } | {
        [x: number]: number;
        readonly BYTES_PER_ELEMENT: number;
        readonly buffer: {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => ArrayBuffer;
          readonly maxByteLength: number;
          readonly resizable: boolean;
          resize: (newByteLength?: number) => void;
          readonly detached: boolean;
          transfer: (newByteLength?: number) => ArrayBuffer;
          transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
          readonly [Symbol.toStringTag]: string;
        } | {
          readonly byteLength: number;
          slice: (begin?: number, end?: number) => SharedArrayBuffer;
          readonly growable: boolean;
          readonly maxByteLength: number;
          grow: (newByteLength?: number) => void;
          readonly [Symbol.species]: SharedArrayBuffer;
          readonly [Symbol.toStringTag]: "SharedArrayBuffer";
        };
        readonly byteLength: number;
        readonly byteOffset: number;
        copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
        every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
        filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
        find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
        findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
        forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
        indexOf: (searchElement: number, fromIndex?: number) => number;
        join: (separator?: string) => string;
        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
        readonly length: number;
        map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
        reduce: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reduceRight: {
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
          (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
          <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
        };
        reverse: () => Float64Array<ArrayBufferLike>;
        set: (array: ArrayLike<number>, offset?: number) => void;
        slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
        some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
        subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
        toLocaleString: {
          (): string;
          (locales: string | string[], options?: Intl.NumberFormatOptions): string;
        };
        toString: () => string;
        valueOf: () => Float64Array<ArrayBufferLike>;
        entries: () => ArrayIterator<[number, number]>;
        keys: () => ArrayIterator<number>;
        values: () => ArrayIterator<number>;
        includes: (searchElement: number, fromIndex?: number) => boolean;
        at: (index: number) => number | undefined;
        findLast: {
          <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
          (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
        };
        findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
        toReversed: () => Float64Array<ArrayBuffer>;
        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
        with: (index: number, value: number) => Float64Array<ArrayBuffer>;
        [Symbol.iterator]: () => ArrayIterator<number>;
        readonly [Symbol.toStringTag]: "Float64Array";
      };
      width: number;
      height: number;
    }[] | {
      readonly isCubeTexture: true;
      image: any;
      images: any;
      mapping: three5.CubeTextureMapping;
      flipY: boolean;
      readonly isTexture: true;
      readonly id: number;
      uuid: string;
      name: string;
      source: {
        readonly isSource: true;
        readonly id: number;
        uuid: string;
        data: any;
        dataReady: boolean;
        version: number;
        getSize: (target: three5.Vector3) => three5.Vector3;
        needsUpdate: boolean;
        toJSON: (meta?: string | {}) => three5.SourceJSON;
      };
      readonly width: number;
      readonly height: number;
      readonly depth: number;
      mipmaps: HTMLCanvasElement[] | {
        data: {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Int8Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Int8Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Int8Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
          with: (index: number, value: number) => Int8Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Int8Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Uint8Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Uint8Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Uint8Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
          with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Uint8Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Uint8ClampedArray<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Uint8ClampedArray<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
          with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Uint8ClampedArray";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Int16Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Int16Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Int16Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
          with: (index: number, value: number) => Int16Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Int16Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Uint16Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Uint16Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Uint16Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
          with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Uint16Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Int32Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Int32Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Int32Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
          with: (index: number, value: number) => Int32Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Int32Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Uint32Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Uint32Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Uint32Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
          with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Uint32Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Float32Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Float32Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Float32Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
          with: (index: number, value: number) => Float32Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Float32Array";
        } | {
          [x: number]: number;
          readonly BYTES_PER_ELEMENT: number;
          readonly buffer: {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => ArrayBuffer;
            readonly maxByteLength: number;
            readonly resizable: boolean;
            resize: (newByteLength?: number) => void;
            readonly detached: boolean;
            transfer: (newByteLength?: number) => ArrayBuffer;
            transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
            readonly [Symbol.toStringTag]: string;
          } | {
            readonly byteLength: number;
            slice: (begin?: number, end?: number) => SharedArrayBuffer;
            readonly growable: boolean;
            readonly maxByteLength: number;
            grow: (newByteLength?: number) => void;
            readonly [Symbol.species]: SharedArrayBuffer;
            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
          };
          readonly byteLength: number;
          readonly byteOffset: number;
          copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
          every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
          filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
          find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
          findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
          forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
          indexOf: (searchElement: number, fromIndex?: number) => number;
          join: (separator?: string) => string;
          lastIndexOf: (searchElement: number, fromIndex?: number) => number;
          readonly length: number;
          map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
          reduce: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reduceRight: {
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
          };
          reverse: () => Float64Array<ArrayBufferLike>;
          set: (array: ArrayLike<number>, offset?: number) => void;
          slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
          some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
          sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
          subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
          toLocaleString: {
            (): string;
            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
          };
          toString: () => string;
          valueOf: () => Float64Array<ArrayBufferLike>;
          entries: () => ArrayIterator<[number, number]>;
          keys: () => ArrayIterator<number>;
          values: () => ArrayIterator<number>;
          includes: (searchElement: number, fromIndex?: number) => boolean;
          at: (index: number) => number | undefined;
          findLast: {
            <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
            (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
          };
          findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
          toReversed: () => Float64Array<ArrayBuffer>;
          toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
          with: (index: number, value: number) => Float64Array<ArrayBuffer>;
          [Symbol.iterator]: () => ArrayIterator<number>;
          readonly [Symbol.toStringTag]: "Float64Array";
        };
        width: number;
        height: number;
      }[] | /*elided*/any[];
      channel: number;
      wrapS: three5.Wrapping;
      wrapT: three5.Wrapping;
      magFilter: three5.MagnificationTextureFilter;
      minFilter: three5.MinificationTextureFilter;
      anisotropy: number;
      format: three5.AnyPixelFormat;
      type: three5.TextureDataType;
      internalFormat: three5.PixelFormatGPU | null;
      matrix: {
        readonly isMatrix3: true;
        elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
        set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => three5.Matrix3;
        identity: () => three5.Matrix3;
        copy: (m: three5.Matrix3) => three5.Matrix3;
        extractBasis: (xAxis: three5.Vector3, yAxis: three5.Vector3, zAxis: three5.Vector3) => three5.Matrix3;
        setFromMatrix4: (m: three5.Matrix4) => three5.Matrix3;
        multiply: (m: three5.Matrix3) => three5.Matrix3;
        premultiply: (m: three5.Matrix3) => three5.Matrix3;
        multiplyMatrices: (a: three5.Matrix3, b: three5.Matrix3) => three5.Matrix3;
        multiplyScalar: (s: number) => three5.Matrix3;
        determinant: () => number;
        invert: () => three5.Matrix3;
        transpose: () => three5.Matrix3;
        getNormalMatrix: (matrix4: three5.Matrix4) => three5.Matrix3;
        transposeIntoArray: (r: number[]) => three5.Matrix3;
        setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => three5.Matrix3;
        scale: (sx: number, sy: number) => three5.Matrix3;
        rotate: (theta: number) => three5.Matrix3;
        translate: (tx: number, ty: number) => three5.Matrix3;
        makeTranslation: {
          (v: three5.Vector2): three5.Matrix3;
          (x: number, y: number): three5.Matrix3;
        };
        makeRotation: (theta: number) => three5.Matrix3;
        makeScale: (x: number, y: number) => three5.Matrix3;
        equals: (matrix: three5.Matrix3) => boolean;
        fromArray: (array: ArrayLike<number>, offset?: number) => three5.Matrix3;
        toArray: {
          (): three5.Matrix3Tuple;
          <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
        };
        clone: () => three5.Matrix3;
      };
      matrixAutoUpdate: boolean;
      offset: {
        x: number;
        y: number;
        width: number;
        height: number;
        readonly isVector2: true;
        set: (x: number, y: number) => three5.Vector2;
        setScalar: (scalar: number) => three5.Vector2;
        setX: (x: number) => three5.Vector2;
        setY: (y: number) => three5.Vector2;
        setComponent: (index: number, value: number) => three5.Vector2;
        getComponent: (index: number) => number;
        clone: () => three5.Vector2;
        copy: (v: three5.Vector2Like) => three5.Vector2;
        add: (v: three5.Vector2Like) => three5.Vector2;
        addScalar: (s: number) => three5.Vector2;
        addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
        sub: (v: three5.Vector2Like) => three5.Vector2;
        subScalar: (s: number) => three5.Vector2;
        subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        multiply: (v: three5.Vector2Like) => three5.Vector2;
        multiplyScalar: (scalar: number) => three5.Vector2;
        divide: (v: three5.Vector2Like) => three5.Vector2;
        divideScalar: (s: number) => three5.Vector2;
        applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
        min: (v: three5.Vector2Like) => three5.Vector2;
        max: (v: three5.Vector2Like) => three5.Vector2;
        clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
        clampScalar: (min: number, max: number) => three5.Vector2;
        clampLength: (min: number, max: number) => three5.Vector2;
        floor: () => three5.Vector2;
        ceil: () => three5.Vector2;
        round: () => three5.Vector2;
        roundToZero: () => three5.Vector2;
        negate: () => three5.Vector2;
        dot: (v: three5.Vector2Like) => number;
        cross: (v: three5.Vector2Like) => number;
        lengthSq: () => number;
        length: () => number;
        manhattanLength: () => number;
        normalize: () => three5.Vector2;
        angle: () => number;
        angleTo: (v: three5.Vector2) => number;
        distanceTo: (v: three5.Vector2Like) => number;
        distanceToSquared: (v: three5.Vector2Like) => number;
        manhattanDistanceTo: (v: three5.Vector2Like) => number;
        setLength: (length: number) => three5.Vector2;
        lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
        lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
        equals: (v: three5.Vector2Like) => boolean;
        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
        toArray: {
          (array?: number[], offset?: number): number[];
          (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
          (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        };
        fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
        rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
        random: () => three5.Vector2;
        [Symbol.iterator]: () => Iterator<number>;
      };
      repeat: {
        x: number;
        y: number;
        width: number;
        height: number;
        readonly isVector2: true;
        set: (x: number, y: number) => three5.Vector2;
        setScalar: (scalar: number) => three5.Vector2;
        setX: (x: number) => three5.Vector2;
        setY: (y: number) => three5.Vector2;
        setComponent: (index: number, value: number) => three5.Vector2;
        getComponent: (index: number) => number;
        clone: () => three5.Vector2;
        copy: (v: three5.Vector2Like) => three5.Vector2;
        add: (v: three5.Vector2Like) => three5.Vector2;
        addScalar: (s: number) => three5.Vector2;
        addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
        sub: (v: three5.Vector2Like) => three5.Vector2;
        subScalar: (s: number) => three5.Vector2;
        subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        multiply: (v: three5.Vector2Like) => three5.Vector2;
        multiplyScalar: (scalar: number) => three5.Vector2;
        divide: (v: three5.Vector2Like) => three5.Vector2;
        divideScalar: (s: number) => three5.Vector2;
        applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
        min: (v: three5.Vector2Like) => three5.Vector2;
        max: (v: three5.Vector2Like) => three5.Vector2;
        clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
        clampScalar: (min: number, max: number) => three5.Vector2;
        clampLength: (min: number, max: number) => three5.Vector2;
        floor: () => three5.Vector2;
        ceil: () => three5.Vector2;
        round: () => three5.Vector2;
        roundToZero: () => three5.Vector2;
        negate: () => three5.Vector2;
        dot: (v: three5.Vector2Like) => number;
        cross: (v: three5.Vector2Like) => number;
        lengthSq: () => number;
        length: () => number;
        manhattanLength: () => number;
        normalize: () => three5.Vector2;
        angle: () => number;
        angleTo: (v: three5.Vector2) => number;
        distanceTo: (v: three5.Vector2Like) => number;
        distanceToSquared: (v: three5.Vector2Like) => number;
        manhattanDistanceTo: (v: three5.Vector2Like) => number;
        setLength: (length: number) => three5.Vector2;
        lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
        lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
        equals: (v: three5.Vector2Like) => boolean;
        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
        toArray: {
          (array?: number[], offset?: number): number[];
          (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
          (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        };
        fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
        rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
        random: () => three5.Vector2;
        [Symbol.iterator]: () => Iterator<number>;
      };
      center: {
        x: number;
        y: number;
        width: number;
        height: number;
        readonly isVector2: true;
        set: (x: number, y: number) => three5.Vector2;
        setScalar: (scalar: number) => three5.Vector2;
        setX: (x: number) => three5.Vector2;
        setY: (y: number) => three5.Vector2;
        setComponent: (index: number, value: number) => three5.Vector2;
        getComponent: (index: number) => number;
        clone: () => three5.Vector2;
        copy: (v: three5.Vector2Like) => three5.Vector2;
        add: (v: three5.Vector2Like) => three5.Vector2;
        addScalar: (s: number) => three5.Vector2;
        addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
        sub: (v: three5.Vector2Like) => three5.Vector2;
        subScalar: (s: number) => three5.Vector2;
        subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
        multiply: (v: three5.Vector2Like) => three5.Vector2;
        multiplyScalar: (scalar: number) => three5.Vector2;
        divide: (v: three5.Vector2Like) => three5.Vector2;
        divideScalar: (s: number) => three5.Vector2;
        applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
        min: (v: three5.Vector2Like) => three5.Vector2;
        max: (v: three5.Vector2Like) => three5.Vector2;
        clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
        clampScalar: (min: number, max: number) => three5.Vector2;
        clampLength: (min: number, max: number) => three5.Vector2;
        floor: () => three5.Vector2;
        ceil: () => three5.Vector2;
        round: () => three5.Vector2;
        roundToZero: () => three5.Vector2;
        negate: () => three5.Vector2;
        dot: (v: three5.Vector2Like) => number;
        cross: (v: three5.Vector2Like) => number;
        lengthSq: () => number;
        length: () => number;
        manhattanLength: () => number;
        normalize: () => three5.Vector2;
        angle: () => number;
        angleTo: (v: three5.Vector2) => number;
        distanceTo: (v: three5.Vector2Like) => number;
        distanceToSquared: (v: three5.Vector2Like) => number;
        manhattanDistanceTo: (v: three5.Vector2Like) => number;
        setLength: (length: number) => three5.Vector2;
        lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
        lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
        equals: (v: three5.Vector2Like) => boolean;
        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
        toArray: {
          (array?: number[], offset?: number): number[];
          (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
          (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        };
        fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
        rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
        random: () => three5.Vector2;
        [Symbol.iterator]: () => Iterator<number>;
      };
      rotation: number;
      generateMipmaps: boolean;
      premultiplyAlpha: boolean;
      unpackAlignment: number;
      colorSpace: string;
      isRenderTargetTexture: boolean;
      isArrayTexture: boolean;
      userData: Record<string, any>;
      updateRanges: {
        start: number;
        count: number;
      }[];
      version: number;
      pmremVersion: number;
      needsUpdate: boolean;
      needsPMREMUpdate: boolean;
      renderTarget: {
        readonly isRenderTarget: true;
        width: number;
        height: number;
        depth: number;
        scissor: {
          x: number;
          y: number;
          z: number;
          w: number;
          width: number;
          height: number;
          readonly isVector4: true;
          set: (x: number, y: number, z: number, w: number) => three5.Vector4;
          setScalar: (scalar: number) => three5.Vector4;
          setX: (x: number) => three5.Vector4;
          setY: (y: number) => three5.Vector4;
          setZ: (z: number) => three5.Vector4;
          setW: (w: number) => three5.Vector4;
          setComponent: (index: number, value: number) => three5.Vector4;
          getComponent: (index: number) => number;
          clone: () => three5.Vector4;
          copy: (v: three5.Vector4Like) => three5.Vector4;
          add: (v: three5.Vector4Like) => three5.Vector4;
          addScalar: (scalar: number) => three5.Vector4;
          addVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
          addScaledVector: (v: three5.Vector4Like, s: number) => three5.Vector4;
          sub: (v: three5.Vector4Like) => three5.Vector4;
          subScalar: (s: number) => three5.Vector4;
          subVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
          multiply: (v: three5.Vector4Like) => three5.Vector4;
          multiplyScalar: (s: number) => three5.Vector4;
          applyMatrix4: (m: three5.Matrix4) => three5.Vector4;
          divide: (v: three5.Vector4Like) => three5.Vector4;
          divideScalar: (s: number) => three5.Vector4;
          setAxisAngleFromQuaternion: (q: three5.QuaternionLike) => three5.Vector4;
          setAxisAngleFromRotationMatrix: (m: three5.Matrix4) => three5.Vector4;
          setFromMatrixPosition: (m: three5.Matrix4) => three5.Vector4;
          min: (v: three5.Vector4Like) => three5.Vector4;
          max: (v: three5.Vector4Like) => three5.Vector4;
          clamp: (min: three5.Vector4Like, max: three5.Vector4Like) => three5.Vector4;
          clampScalar: (min: number, max: number) => three5.Vector4;
          floor: () => three5.Vector4;
          ceil: () => three5.Vector4;
          round: () => three5.Vector4;
          roundToZero: () => three5.Vector4;
          negate: () => three5.Vector4;
          dot: (v: three5.Vector4Like) => number;
          lengthSq: () => number;
          length: () => number;
          manhattanLength: () => number;
          normalize: () => three5.Vector4;
          setLength: (length: number) => three5.Vector4;
          lerp: (v: three5.Vector4Like, alpha: number) => three5.Vector4;
          lerpVectors: (v1: three5.Vector4Like, v2: three5.Vector4Like, alpha: number) => three5.Vector4;
          equals: (v: three5.Vector4Like) => boolean;
          fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector4;
          toArray: {
            (array?: number[], offset?: number): number[];
            (array?: three5.Vector4Tuple, offset?: 0): three5.Vector4Tuple;
            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
          };
          fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector4;
          random: () => three5.Vector4;
          [Symbol.iterator]: () => Iterator<number>;
        };
        scissorTest: boolean;
        viewport: {
          x: number;
          y: number;
          z: number;
          w: number;
          width: number;
          height: number;
          readonly isVector4: true;
          set: (x: number, y: number, z: number, w: number) => three5.Vector4;
          setScalar: (scalar: number) => three5.Vector4;
          setX: (x: number) => three5.Vector4;
          setY: (y: number) => three5.Vector4;
          setZ: (z: number) => three5.Vector4;
          setW: (w: number) => three5.Vector4;
          setComponent: (index: number, value: number) => three5.Vector4;
          getComponent: (index: number) => number;
          clone: () => three5.Vector4;
          copy: (v: three5.Vector4Like) => three5.Vector4;
          add: (v: three5.Vector4Like) => three5.Vector4;
          addScalar: (scalar: number) => three5.Vector4;
          addVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
          addScaledVector: (v: three5.Vector4Like, s: number) => three5.Vector4;
          sub: (v: three5.Vector4Like) => three5.Vector4;
          subScalar: (s: number) => three5.Vector4;
          subVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
          multiply: (v: three5.Vector4Like) => three5.Vector4;
          multiplyScalar: (s: number) => three5.Vector4;
          applyMatrix4: (m: three5.Matrix4) => three5.Vector4;
          divide: (v: three5.Vector4Like) => three5.Vector4;
          divideScalar: (s: number) => three5.Vector4;
          setAxisAngleFromQuaternion: (q: three5.QuaternionLike) => three5.Vector4;
          setAxisAngleFromRotationMatrix: (m: three5.Matrix4) => three5.Vector4;
          setFromMatrixPosition: (m: three5.Matrix4) => three5.Vector4;
          min: (v: three5.Vector4Like) => three5.Vector4;
          max: (v: three5.Vector4Like) => three5.Vector4;
          clamp: (min: three5.Vector4Like, max: three5.Vector4Like) => three5.Vector4;
          clampScalar: (min: number, max: number) => three5.Vector4;
          floor: () => three5.Vector4;
          ceil: () => three5.Vector4;
          round: () => three5.Vector4;
          roundToZero: () => three5.Vector4;
          negate: () => three5.Vector4;
          dot: (v: three5.Vector4Like) => number;
          lengthSq: () => number;
          length: () => number;
          manhattanLength: () => number;
          normalize: () => three5.Vector4;
          setLength: (length: number) => three5.Vector4;
          lerp: (v: three5.Vector4Like, alpha: number) => three5.Vector4;
          lerpVectors: (v1: three5.Vector4Like, v2: three5.Vector4Like, alpha: number) => three5.Vector4;
          equals: (v: three5.Vector4Like) => boolean;
          fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector4;
          toArray: {
            (array?: number[], offset?: number): number[];
            (array?: three5.Vector4Tuple, offset?: 0): three5.Vector4Tuple;
            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
          };
          fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector4;
          random: () => three5.Vector4;
          [Symbol.iterator]: () => Iterator<number>;
        };
        textures: /*elided*/any[];
        depthBuffer: boolean;
        stencilBuffer: boolean;
        resolveDepthBuffer: boolean;
        resolveStencilBuffer: boolean;
        samples: number;
        multiview: boolean;
        texture: /*elided*/any;
        depthTexture: {
          readonly isDepthTexture: true;
          image: {
            width: number;
            height: number;
            depth: number;
          };
          flipY: boolean;
          magFilter: three5.MagnificationTextureFilter;
          minFilter: three5.MinificationTextureFilter;
          generateMipmaps: boolean;
          format: three5.DepthTexturePixelFormat;
          type: three5.TextureDataType;
          compareFunction: three5.TextureComparisonFunction | null;
          readonly isTexture: true;
          readonly id: number;
          uuid: string;
          name: string;
          source: {
            readonly isSource: true;
            readonly id: number;
            uuid: string;
            data: any;
            dataReady: boolean;
            version: number;
            getSize: (target: three5.Vector3) => three5.Vector3;
            needsUpdate: boolean;
            toJSON: (meta?: string | {}) => three5.SourceJSON;
          };
          readonly width: number;
          readonly height: number;
          readonly depth: number;
          mipmaps: HTMLCanvasElement[] | {
            data: {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int8Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int8Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int8Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
              with: (index: number, value: number) => Int8Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int8Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint8Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint8Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint8Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint8Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint8ClampedArray<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint8ClampedArray<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
              with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint8ClampedArray";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int16Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int16Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int16Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
              with: (index: number, value: number) => Int16Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int16Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint16Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint16Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint16Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint16Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
              with: (index: number, value: number) => Int32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Float32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Float32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Float32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
              with: (index: number, value: number) => Float32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Float32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Float64Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Float64Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Float64Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
              with: (index: number, value: number) => Float64Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Float64Array";
            };
            width: number;
            height: number;
          }[] | /*elided*/any[];
          mapping: three5.AnyMapping;
          channel: number;
          wrapS: three5.Wrapping;
          wrapT: three5.Wrapping;
          anisotropy: number;
          internalFormat: three5.PixelFormatGPU | null;
          matrix: {
            readonly isMatrix3: true;
            elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => three5.Matrix3;
            identity: () => three5.Matrix3;
            copy: (m: three5.Matrix3) => three5.Matrix3;
            extractBasis: (xAxis: three5.Vector3, yAxis: three5.Vector3, zAxis: three5.Vector3) => three5.Matrix3;
            setFromMatrix4: (m: three5.Matrix4) => three5.Matrix3;
            multiply: (m: three5.Matrix3) => three5.Matrix3;
            premultiply: (m: three5.Matrix3) => three5.Matrix3;
            multiplyMatrices: (a: three5.Matrix3, b: three5.Matrix3) => three5.Matrix3;
            multiplyScalar: (s: number) => three5.Matrix3;
            determinant: () => number;
            invert: () => three5.Matrix3;
            transpose: () => three5.Matrix3;
            getNormalMatrix: (matrix4: three5.Matrix4) => three5.Matrix3;
            transposeIntoArray: (r: number[]) => three5.Matrix3;
            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => three5.Matrix3;
            scale: (sx: number, sy: number) => three5.Matrix3;
            rotate: (theta: number) => three5.Matrix3;
            translate: (tx: number, ty: number) => three5.Matrix3;
            makeTranslation: {
              (v: three5.Vector2): three5.Matrix3;
              (x: number, y: number): three5.Matrix3;
            };
            makeRotation: (theta: number) => three5.Matrix3;
            makeScale: (x: number, y: number) => three5.Matrix3;
            equals: (matrix: three5.Matrix3) => boolean;
            fromArray: (array: ArrayLike<number>, offset?: number) => three5.Matrix3;
            toArray: {
              (): three5.Matrix3Tuple;
              <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
            };
            clone: () => three5.Matrix3;
          };
          matrixAutoUpdate: boolean;
          offset: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          repeat: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          center: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          rotation: number;
          premultiplyAlpha: boolean;
          unpackAlignment: number;
          colorSpace: string;
          isRenderTargetTexture: boolean;
          isArrayTexture: boolean;
          userData: Record<string, any>;
          updateRanges: {
            start: number;
            count: number;
          }[];
          version: number;
          pmremVersion: number;
          needsUpdate: boolean;
          needsPMREMUpdate: boolean;
          renderTarget: /*elided*/any | null;
          onUpdate: ((texture: Texture) => void) | null;
          transformUv: (uv: three5.Vector2) => three5.Vector2;
          updateMatrix: () => void;
          addUpdateRange: (start: number, count: number) => void;
          clearUpdateRanges: () => void;
          clone: () => three5.DepthTexture;
          copy: (source: Texture) => three5.DepthTexture;
          setValues: (values: three5.TextureParameters) => void;
          toJSON: (meta?: string | {}) => three5.TextureJSON;
          dispose: () => void;
          addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.DepthTexture>) => void;
          hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.DepthTexture>) => boolean;
          removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.DepthTexture>) => void;
          dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
            dispose: {};
          }[T]) => void;
        } | null;
        setSize: (width: number, height: number, depth?: number) => void;
        clone: () => three5.RenderTarget<Texture>;
        copy: (source: three5.RenderTarget) => three5.RenderTarget<Texture>;
        dispose: () => void;
        addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.RenderTarget<Texture>>) => void;
        hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.RenderTarget<Texture>>) => boolean;
        removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.RenderTarget<Texture>>) => void;
        dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
          dispose: {};
        }[T]) => void;
      } | null;
      onUpdate: ((texture: Texture) => void) | null;
      transformUv: (uv: three5.Vector2) => three5.Vector2;
      updateMatrix: () => void;
      addUpdateRange: (start: number, count: number) => void;
      clearUpdateRanges: () => void;
      clone: () => three5.CubeTexture;
      copy: (source: Texture) => three5.CubeTexture;
      setValues: (values: three5.TextureParameters) => void;
      toJSON: (meta?: string | {}) => three5.TextureJSON;
      dispose: () => void;
      addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.CubeTexture>) => void;
      hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.CubeTexture>) => boolean;
      removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.CubeTexture>) => void;
      dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
        dispose: {};
      }[T]) => void;
    }[];
    mapping: three5.AnyMapping;
    channel: number;
    wrapS: three5.Wrapping;
    wrapT: three5.Wrapping;
    magFilter: three5.MagnificationTextureFilter;
    minFilter: three5.MinificationTextureFilter;
    anisotropy: number;
    format: three5.AnyPixelFormat;
    type: three5.TextureDataType;
    internalFormat: three5.PixelFormatGPU | null;
    matrix: {
      readonly isMatrix3: true;
      elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
      set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => three5.Matrix3;
      identity: () => three5.Matrix3;
      copy: (m: three5.Matrix3) => three5.Matrix3;
      extractBasis: (xAxis: three5.Vector3, yAxis: three5.Vector3, zAxis: three5.Vector3) => three5.Matrix3;
      setFromMatrix4: (m: three5.Matrix4) => three5.Matrix3;
      multiply: (m: three5.Matrix3) => three5.Matrix3;
      premultiply: (m: three5.Matrix3) => three5.Matrix3;
      multiplyMatrices: (a: three5.Matrix3, b: three5.Matrix3) => three5.Matrix3;
      multiplyScalar: (s: number) => three5.Matrix3;
      determinant: () => number;
      invert: () => three5.Matrix3;
      transpose: () => three5.Matrix3;
      getNormalMatrix: (matrix4: three5.Matrix4) => three5.Matrix3;
      transposeIntoArray: (r: number[]) => three5.Matrix3;
      setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => three5.Matrix3;
      scale: (sx: number, sy: number) => three5.Matrix3;
      rotate: (theta: number) => three5.Matrix3;
      translate: (tx: number, ty: number) => three5.Matrix3;
      makeTranslation: {
        (v: three5.Vector2): three5.Matrix3;
        (x: number, y: number): three5.Matrix3;
      };
      makeRotation: (theta: number) => three5.Matrix3;
      makeScale: (x: number, y: number) => three5.Matrix3;
      equals: (matrix: three5.Matrix3) => boolean;
      fromArray: (array: ArrayLike<number>, offset?: number) => three5.Matrix3;
      toArray: {
        (): three5.Matrix3Tuple;
        <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
      };
      clone: () => three5.Matrix3;
    };
    matrixAutoUpdate: boolean;
    offset: {
      x: number;
      y: number;
      width: number;
      height: number;
      readonly isVector2: true;
      set: (x: number, y: number) => three5.Vector2;
      setScalar: (scalar: number) => three5.Vector2;
      setX: (x: number) => three5.Vector2;
      setY: (y: number) => three5.Vector2;
      setComponent: (index: number, value: number) => three5.Vector2;
      getComponent: (index: number) => number;
      clone: () => three5.Vector2;
      copy: (v: three5.Vector2Like) => three5.Vector2;
      add: (v: three5.Vector2Like) => three5.Vector2;
      addScalar: (s: number) => three5.Vector2;
      addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
      sub: (v: three5.Vector2Like) => three5.Vector2;
      subScalar: (s: number) => three5.Vector2;
      subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      multiply: (v: three5.Vector2Like) => three5.Vector2;
      multiplyScalar: (scalar: number) => three5.Vector2;
      divide: (v: three5.Vector2Like) => three5.Vector2;
      divideScalar: (s: number) => three5.Vector2;
      applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
      min: (v: three5.Vector2Like) => three5.Vector2;
      max: (v: three5.Vector2Like) => three5.Vector2;
      clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
      clampScalar: (min: number, max: number) => three5.Vector2;
      clampLength: (min: number, max: number) => three5.Vector2;
      floor: () => three5.Vector2;
      ceil: () => three5.Vector2;
      round: () => three5.Vector2;
      roundToZero: () => three5.Vector2;
      negate: () => three5.Vector2;
      dot: (v: three5.Vector2Like) => number;
      cross: (v: three5.Vector2Like) => number;
      lengthSq: () => number;
      length: () => number;
      manhattanLength: () => number;
      normalize: () => three5.Vector2;
      angle: () => number;
      angleTo: (v: three5.Vector2) => number;
      distanceTo: (v: three5.Vector2Like) => number;
      distanceToSquared: (v: three5.Vector2Like) => number;
      manhattanDistanceTo: (v: three5.Vector2Like) => number;
      setLength: (length: number) => three5.Vector2;
      lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
      lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
      equals: (v: three5.Vector2Like) => boolean;
      fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
      toArray: {
        (array?: number[], offset?: number): number[];
        (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
      };
      fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
      rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
      random: () => three5.Vector2;
      [Symbol.iterator]: () => Iterator<number>;
    };
    repeat: {
      x: number;
      y: number;
      width: number;
      height: number;
      readonly isVector2: true;
      set: (x: number, y: number) => three5.Vector2;
      setScalar: (scalar: number) => three5.Vector2;
      setX: (x: number) => three5.Vector2;
      setY: (y: number) => three5.Vector2;
      setComponent: (index: number, value: number) => three5.Vector2;
      getComponent: (index: number) => number;
      clone: () => three5.Vector2;
      copy: (v: three5.Vector2Like) => three5.Vector2;
      add: (v: three5.Vector2Like) => three5.Vector2;
      addScalar: (s: number) => three5.Vector2;
      addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
      sub: (v: three5.Vector2Like) => three5.Vector2;
      subScalar: (s: number) => three5.Vector2;
      subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      multiply: (v: three5.Vector2Like) => three5.Vector2;
      multiplyScalar: (scalar: number) => three5.Vector2;
      divide: (v: three5.Vector2Like) => three5.Vector2;
      divideScalar: (s: number) => three5.Vector2;
      applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
      min: (v: three5.Vector2Like) => three5.Vector2;
      max: (v: three5.Vector2Like) => three5.Vector2;
      clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
      clampScalar: (min: number, max: number) => three5.Vector2;
      clampLength: (min: number, max: number) => three5.Vector2;
      floor: () => three5.Vector2;
      ceil: () => three5.Vector2;
      round: () => three5.Vector2;
      roundToZero: () => three5.Vector2;
      negate: () => three5.Vector2;
      dot: (v: three5.Vector2Like) => number;
      cross: (v: three5.Vector2Like) => number;
      lengthSq: () => number;
      length: () => number;
      manhattanLength: () => number;
      normalize: () => three5.Vector2;
      angle: () => number;
      angleTo: (v: three5.Vector2) => number;
      distanceTo: (v: three5.Vector2Like) => number;
      distanceToSquared: (v: three5.Vector2Like) => number;
      manhattanDistanceTo: (v: three5.Vector2Like) => number;
      setLength: (length: number) => three5.Vector2;
      lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
      lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
      equals: (v: three5.Vector2Like) => boolean;
      fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
      toArray: {
        (array?: number[], offset?: number): number[];
        (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
      };
      fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
      rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
      random: () => three5.Vector2;
      [Symbol.iterator]: () => Iterator<number>;
    };
    center: {
      x: number;
      y: number;
      width: number;
      height: number;
      readonly isVector2: true;
      set: (x: number, y: number) => three5.Vector2;
      setScalar: (scalar: number) => three5.Vector2;
      setX: (x: number) => three5.Vector2;
      setY: (y: number) => three5.Vector2;
      setComponent: (index: number, value: number) => three5.Vector2;
      getComponent: (index: number) => number;
      clone: () => three5.Vector2;
      copy: (v: three5.Vector2Like) => three5.Vector2;
      add: (v: three5.Vector2Like) => three5.Vector2;
      addScalar: (s: number) => three5.Vector2;
      addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
      sub: (v: three5.Vector2Like) => three5.Vector2;
      subScalar: (s: number) => three5.Vector2;
      subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
      multiply: (v: three5.Vector2Like) => three5.Vector2;
      multiplyScalar: (scalar: number) => three5.Vector2;
      divide: (v: three5.Vector2Like) => three5.Vector2;
      divideScalar: (s: number) => three5.Vector2;
      applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
      min: (v: three5.Vector2Like) => three5.Vector2;
      max: (v: three5.Vector2Like) => three5.Vector2;
      clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
      clampScalar: (min: number, max: number) => three5.Vector2;
      clampLength: (min: number, max: number) => three5.Vector2;
      floor: () => three5.Vector2;
      ceil: () => three5.Vector2;
      round: () => three5.Vector2;
      roundToZero: () => three5.Vector2;
      negate: () => three5.Vector2;
      dot: (v: three5.Vector2Like) => number;
      cross: (v: three5.Vector2Like) => number;
      lengthSq: () => number;
      length: () => number;
      manhattanLength: () => number;
      normalize: () => three5.Vector2;
      angle: () => number;
      angleTo: (v: three5.Vector2) => number;
      distanceTo: (v: three5.Vector2Like) => number;
      distanceToSquared: (v: three5.Vector2Like) => number;
      manhattanDistanceTo: (v: three5.Vector2Like) => number;
      setLength: (length: number) => three5.Vector2;
      lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
      lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
      equals: (v: three5.Vector2Like) => boolean;
      fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
      toArray: {
        (array?: number[], offset?: number): number[];
        (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
      };
      fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
      rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
      random: () => three5.Vector2;
      [Symbol.iterator]: () => Iterator<number>;
    };
    rotation: number;
    generateMipmaps: boolean;
    premultiplyAlpha: boolean;
    flipY: boolean;
    unpackAlignment: number;
    colorSpace: string;
    isRenderTargetTexture: boolean;
    isArrayTexture: boolean;
    userData: Record<string, any>;
    updateRanges: {
      start: number;
      count: number;
    }[];
    version: number;
    pmremVersion: number;
    needsUpdate: boolean;
    needsPMREMUpdate: boolean;
    renderTarget: {
      readonly isRenderTarget: true;
      width: number;
      height: number;
      depth: number;
      scissor: {
        x: number;
        y: number;
        z: number;
        w: number;
        width: number;
        height: number;
        readonly isVector4: true;
        set: (x: number, y: number, z: number, w: number) => three5.Vector4;
        setScalar: (scalar: number) => three5.Vector4;
        setX: (x: number) => three5.Vector4;
        setY: (y: number) => three5.Vector4;
        setZ: (z: number) => three5.Vector4;
        setW: (w: number) => three5.Vector4;
        setComponent: (index: number, value: number) => three5.Vector4;
        getComponent: (index: number) => number;
        clone: () => three5.Vector4;
        copy: (v: three5.Vector4Like) => three5.Vector4;
        add: (v: three5.Vector4Like) => three5.Vector4;
        addScalar: (scalar: number) => three5.Vector4;
        addVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
        addScaledVector: (v: three5.Vector4Like, s: number) => three5.Vector4;
        sub: (v: three5.Vector4Like) => three5.Vector4;
        subScalar: (s: number) => three5.Vector4;
        subVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
        multiply: (v: three5.Vector4Like) => three5.Vector4;
        multiplyScalar: (s: number) => three5.Vector4;
        applyMatrix4: (m: three5.Matrix4) => three5.Vector4;
        divide: (v: three5.Vector4Like) => three5.Vector4;
        divideScalar: (s: number) => three5.Vector4;
        setAxisAngleFromQuaternion: (q: three5.QuaternionLike) => three5.Vector4;
        setAxisAngleFromRotationMatrix: (m: three5.Matrix4) => three5.Vector4;
        setFromMatrixPosition: (m: three5.Matrix4) => three5.Vector4;
        min: (v: three5.Vector4Like) => three5.Vector4;
        max: (v: three5.Vector4Like) => three5.Vector4;
        clamp: (min: three5.Vector4Like, max: three5.Vector4Like) => three5.Vector4;
        clampScalar: (min: number, max: number) => three5.Vector4;
        floor: () => three5.Vector4;
        ceil: () => three5.Vector4;
        round: () => three5.Vector4;
        roundToZero: () => three5.Vector4;
        negate: () => three5.Vector4;
        dot: (v: three5.Vector4Like) => number;
        lengthSq: () => number;
        length: () => number;
        manhattanLength: () => number;
        normalize: () => three5.Vector4;
        setLength: (length: number) => three5.Vector4;
        lerp: (v: three5.Vector4Like, alpha: number) => three5.Vector4;
        lerpVectors: (v1: three5.Vector4Like, v2: three5.Vector4Like, alpha: number) => three5.Vector4;
        equals: (v: three5.Vector4Like) => boolean;
        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector4;
        toArray: {
          (array?: number[], offset?: number): number[];
          (array?: three5.Vector4Tuple, offset?: 0): three5.Vector4Tuple;
          (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        };
        fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector4;
        random: () => three5.Vector4;
        [Symbol.iterator]: () => Iterator<number>;
      };
      scissorTest: boolean;
      viewport: {
        x: number;
        y: number;
        z: number;
        w: number;
        width: number;
        height: number;
        readonly isVector4: true;
        set: (x: number, y: number, z: number, w: number) => three5.Vector4;
        setScalar: (scalar: number) => three5.Vector4;
        setX: (x: number) => three5.Vector4;
        setY: (y: number) => three5.Vector4;
        setZ: (z: number) => three5.Vector4;
        setW: (w: number) => three5.Vector4;
        setComponent: (index: number, value: number) => three5.Vector4;
        getComponent: (index: number) => number;
        clone: () => three5.Vector4;
        copy: (v: three5.Vector4Like) => three5.Vector4;
        add: (v: three5.Vector4Like) => three5.Vector4;
        addScalar: (scalar: number) => three5.Vector4;
        addVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
        addScaledVector: (v: three5.Vector4Like, s: number) => three5.Vector4;
        sub: (v: three5.Vector4Like) => three5.Vector4;
        subScalar: (s: number) => three5.Vector4;
        subVectors: (a: three5.Vector4Like, b: three5.Vector4Like) => three5.Vector4;
        multiply: (v: three5.Vector4Like) => three5.Vector4;
        multiplyScalar: (s: number) => three5.Vector4;
        applyMatrix4: (m: three5.Matrix4) => three5.Vector4;
        divide: (v: three5.Vector4Like) => three5.Vector4;
        divideScalar: (s: number) => three5.Vector4;
        setAxisAngleFromQuaternion: (q: three5.QuaternionLike) => three5.Vector4;
        setAxisAngleFromRotationMatrix: (m: three5.Matrix4) => three5.Vector4;
        setFromMatrixPosition: (m: three5.Matrix4) => three5.Vector4;
        min: (v: three5.Vector4Like) => three5.Vector4;
        max: (v: three5.Vector4Like) => three5.Vector4;
        clamp: (min: three5.Vector4Like, max: three5.Vector4Like) => three5.Vector4;
        clampScalar: (min: number, max: number) => three5.Vector4;
        floor: () => three5.Vector4;
        ceil: () => three5.Vector4;
        round: () => three5.Vector4;
        roundToZero: () => three5.Vector4;
        negate: () => three5.Vector4;
        dot: (v: three5.Vector4Like) => number;
        lengthSq: () => number;
        length: () => number;
        manhattanLength: () => number;
        normalize: () => three5.Vector4;
        setLength: (length: number) => three5.Vector4;
        lerp: (v: three5.Vector4Like, alpha: number) => three5.Vector4;
        lerpVectors: (v1: three5.Vector4Like, v2: three5.Vector4Like, alpha: number) => three5.Vector4;
        equals: (v: three5.Vector4Like) => boolean;
        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector4;
        toArray: {
          (array?: number[], offset?: number): number[];
          (array?: three5.Vector4Tuple, offset?: 0): three5.Vector4Tuple;
          (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        };
        fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector4;
        random: () => three5.Vector4;
        [Symbol.iterator]: () => Iterator<number>;
      };
      textures: /*elided*/any[];
      depthBuffer: boolean;
      stencilBuffer: boolean;
      resolveDepthBuffer: boolean;
      resolveStencilBuffer: boolean;
      samples: number;
      multiview: boolean;
      texture: /*elided*/any;
      depthTexture: {
        readonly isDepthTexture: true;
        image: {
          width: number;
          height: number;
          depth: number;
        };
        flipY: boolean;
        magFilter: three5.MagnificationTextureFilter;
        minFilter: three5.MinificationTextureFilter;
        generateMipmaps: boolean;
        format: three5.DepthTexturePixelFormat;
        type: three5.TextureDataType;
        compareFunction: three5.TextureComparisonFunction | null;
        readonly isTexture: true;
        readonly id: number;
        uuid: string;
        name: string;
        source: {
          readonly isSource: true;
          readonly id: number;
          uuid: string;
          data: any;
          dataReady: boolean;
          version: number;
          getSize: (target: three5.Vector3) => three5.Vector3;
          needsUpdate: boolean;
          toJSON: (meta?: string | {}) => three5.SourceJSON;
        };
        readonly width: number;
        readonly height: number;
        readonly depth: number;
        mipmaps: HTMLCanvasElement[] | {
          data: {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Int8Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Int8Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Int8Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
            with: (index: number, value: number) => Int8Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Int8Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Uint8Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Uint8Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Uint8Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
            with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Uint8Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Uint8ClampedArray<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Uint8ClampedArray<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
            with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Uint8ClampedArray";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Int16Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Int16Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Int16Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
            with: (index: number, value: number) => Int16Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Int16Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Uint16Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Uint16Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Uint16Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
            with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Uint16Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Int32Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Int32Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Int32Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
            with: (index: number, value: number) => Int32Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Int32Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Uint32Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Uint32Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Uint32Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
            with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Uint32Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Float32Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Float32Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Float32Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
            with: (index: number, value: number) => Float32Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Float32Array";
          } | {
            [x: number]: number;
            readonly BYTES_PER_ELEMENT: number;
            readonly buffer: {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => ArrayBuffer;
              readonly maxByteLength: number;
              readonly resizable: boolean;
              resize: (newByteLength?: number) => void;
              readonly detached: boolean;
              transfer: (newByteLength?: number) => ArrayBuffer;
              transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
              readonly [Symbol.toStringTag]: string;
            } | {
              readonly byteLength: number;
              slice: (begin?: number, end?: number) => SharedArrayBuffer;
              readonly growable: boolean;
              readonly maxByteLength: number;
              grow: (newByteLength?: number) => void;
              readonly [Symbol.species]: SharedArrayBuffer;
              readonly [Symbol.toStringTag]: "SharedArrayBuffer";
            };
            readonly byteLength: number;
            readonly byteOffset: number;
            copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
            every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
            filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
            find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
            findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
            forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
            indexOf: (searchElement: number, fromIndex?: number) => number;
            join: (separator?: string) => string;
            lastIndexOf: (searchElement: number, fromIndex?: number) => number;
            readonly length: number;
            map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
            reduce: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reduceRight: {
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
              (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
              <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
            };
            reverse: () => Float64Array<ArrayBufferLike>;
            set: (array: ArrayLike<number>, offset?: number) => void;
            slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
            some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
            subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
            toLocaleString: {
              (): string;
              (locales: string | string[], options?: Intl.NumberFormatOptions): string;
            };
            toString: () => string;
            valueOf: () => Float64Array<ArrayBufferLike>;
            entries: () => ArrayIterator<[number, number]>;
            keys: () => ArrayIterator<number>;
            values: () => ArrayIterator<number>;
            includes: (searchElement: number, fromIndex?: number) => boolean;
            at: (index: number) => number | undefined;
            findLast: {
              <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
              (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
            };
            findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
            toReversed: () => Float64Array<ArrayBuffer>;
            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
            with: (index: number, value: number) => Float64Array<ArrayBuffer>;
            [Symbol.iterator]: () => ArrayIterator<number>;
            readonly [Symbol.toStringTag]: "Float64Array";
          };
          width: number;
          height: number;
        }[] | {
          readonly isCubeTexture: true;
          image: any;
          images: any;
          mapping: three5.CubeTextureMapping;
          flipY: boolean;
          readonly isTexture: true;
          readonly id: number;
          uuid: string;
          name: string;
          source: {
            readonly isSource: true;
            readonly id: number;
            uuid: string;
            data: any;
            dataReady: boolean;
            version: number;
            getSize: (target: three5.Vector3) => three5.Vector3;
            needsUpdate: boolean;
            toJSON: (meta?: string | {}) => three5.SourceJSON;
          };
          readonly width: number;
          readonly height: number;
          readonly depth: number;
          mipmaps: HTMLCanvasElement[] | {
            data: {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int8Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int8Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int8Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int8Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int8Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int8Array<ArrayBuffer>;
              with: (index: number, value: number) => Int8Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int8Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => any, thisArg?: any) => Uint8Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => number, thisArg?: any) => Uint8Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint8Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint8Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint8Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint8Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint8Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint8Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint8Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint8Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => any, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint8ClampedArray<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, thisArg?: any) => Uint8ClampedArray<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint8ClampedArray<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint8ClampedArray<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint8ClampedArray<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint8ClampedArray<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint8ClampedArray<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint8ClampedArray<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint8ClampedArray<ArrayBuffer>;
              with: (index: number, value: number) => Uint8ClampedArray<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint8ClampedArray";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int16Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int16Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => any, thisArg?: any) => Int16Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => number, thisArg?: any) => Int16Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int16Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int16Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int16Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int16Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int16Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int16Array<ArrayBuffer>;
              with: (index: number, value: number) => Int16Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int16Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint16Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint16Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => any, thisArg?: any) => Uint16Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint16Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => number, thisArg?: any) => Uint16Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint16Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint16Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint16Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint16Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint16Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint16Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint16Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint16Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint16Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Int32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Int32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => any, thisArg?: any) => Int32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Int32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => number, thisArg?: any) => Int32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Int32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Int32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Int32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Int32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Int32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Int32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Int32Array<ArrayBuffer>;
              with: (index: number, value: number) => Int32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Int32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Uint32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Uint32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => any, thisArg?: any) => Uint32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Uint32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => number, thisArg?: any) => Uint32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Uint32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Uint32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Uint32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Uint32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Uint32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Uint32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Uint32Array<ArrayBuffer>;
              with: (index: number, value: number) => Uint32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Uint32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Float32Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Float32Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => any, thisArg?: any) => Float32Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Float32Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => number, thisArg?: any) => Float32Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Float32Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Float32Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Float32Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Float32Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Float32Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Float32Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array<ArrayBuffer>;
              with: (index: number, value: number) => Float32Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Float32Array";
            } | {
              [x: number]: number;
              readonly BYTES_PER_ELEMENT: number;
              readonly buffer: {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => ArrayBuffer;
                readonly maxByteLength: number;
                readonly resizable: boolean;
                resize: (newByteLength?: number) => void;
                readonly detached: boolean;
                transfer: (newByteLength?: number) => ArrayBuffer;
                transferToFixedLength: (newByteLength?: number) => ArrayBuffer;
                readonly [Symbol.toStringTag]: string;
              } | {
                readonly byteLength: number;
                slice: (begin?: number, end?: number) => SharedArrayBuffer;
                readonly growable: boolean;
                readonly maxByteLength: number;
                grow: (newByteLength?: number) => void;
                readonly [Symbol.species]: SharedArrayBuffer;
                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
              };
              readonly byteLength: number;
              readonly byteOffset: number;
              copyWithin: (target: number, start: number, end?: number) => Float64Array<ArrayBufferLike>;
              every: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              fill: (value: number, start?: number, end?: number) => Float64Array<ArrayBufferLike>;
              filter: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => any, thisArg?: any) => Float64Array<ArrayBuffer>;
              find: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number | undefined;
              findIndex: (predicate: (value: number, index: number, obj: Float64Array<ArrayBufferLike>) => boolean, thisArg?: any) => number;
              forEach: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => void, thisArg?: any) => void;
              indexOf: (searchElement: number, fromIndex?: number) => number;
              join: (separator?: string) => string;
              lastIndexOf: (searchElement: number, fromIndex?: number) => number;
              readonly length: number;
              map: (callbackfn: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => number, thisArg?: any) => Float64Array<ArrayBuffer>;
              reduce: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reduceRight: {
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number): number;
                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => number, initialValue: number): number;
                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array<ArrayBufferLike>) => U, initialValue: U): U;
              };
              reverse: () => Float64Array<ArrayBufferLike>;
              set: (array: ArrayLike<number>, offset?: number) => void;
              slice: (start?: number, end?: number) => Float64Array<ArrayBuffer>;
              some: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean;
              sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBufferLike>;
              subarray: (begin?: number, end?: number) => Float64Array<ArrayBufferLike>;
              toLocaleString: {
                (): string;
                (locales: string | string[], options?: Intl.NumberFormatOptions): string;
              };
              toString: () => string;
              valueOf: () => Float64Array<ArrayBufferLike>;
              entries: () => ArrayIterator<[number, number]>;
              keys: () => ArrayIterator<number>;
              values: () => ArrayIterator<number>;
              includes: (searchElement: number, fromIndex?: number) => boolean;
              at: (index: number) => number | undefined;
              findLast: {
                <S extends number>(predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => value is S, thisArg?: any): S | undefined;
                (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any): number | undefined;
              };
              findLastIndex: (predicate: (value: number, index: number, array: Float64Array<ArrayBufferLike>) => unknown, thisArg?: any) => number;
              toReversed: () => Float64Array<ArrayBuffer>;
              toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float64Array<ArrayBuffer>;
              with: (index: number, value: number) => Float64Array<ArrayBuffer>;
              [Symbol.iterator]: () => ArrayIterator<number>;
              readonly [Symbol.toStringTag]: "Float64Array";
            };
            width: number;
            height: number;
          }[] | /*elided*/any[];
          channel: number;
          wrapS: three5.Wrapping;
          wrapT: three5.Wrapping;
          magFilter: three5.MagnificationTextureFilter;
          minFilter: three5.MinificationTextureFilter;
          anisotropy: number;
          format: three5.AnyPixelFormat;
          type: three5.TextureDataType;
          internalFormat: three5.PixelFormatGPU | null;
          matrix: {
            readonly isMatrix3: true;
            elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => three5.Matrix3;
            identity: () => three5.Matrix3;
            copy: (m: three5.Matrix3) => three5.Matrix3;
            extractBasis: (xAxis: three5.Vector3, yAxis: three5.Vector3, zAxis: three5.Vector3) => three5.Matrix3;
            setFromMatrix4: (m: three5.Matrix4) => three5.Matrix3;
            multiply: (m: three5.Matrix3) => three5.Matrix3;
            premultiply: (m: three5.Matrix3) => three5.Matrix3;
            multiplyMatrices: (a: three5.Matrix3, b: three5.Matrix3) => three5.Matrix3;
            multiplyScalar: (s: number) => three5.Matrix3;
            determinant: () => number;
            invert: () => three5.Matrix3;
            transpose: () => three5.Matrix3;
            getNormalMatrix: (matrix4: three5.Matrix4) => three5.Matrix3;
            transposeIntoArray: (r: number[]) => three5.Matrix3;
            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => three5.Matrix3;
            scale: (sx: number, sy: number) => three5.Matrix3;
            rotate: (theta: number) => three5.Matrix3;
            translate: (tx: number, ty: number) => three5.Matrix3;
            makeTranslation: {
              (v: three5.Vector2): three5.Matrix3;
              (x: number, y: number): three5.Matrix3;
            };
            makeRotation: (theta: number) => three5.Matrix3;
            makeScale: (x: number, y: number) => three5.Matrix3;
            equals: (matrix: three5.Matrix3) => boolean;
            fromArray: (array: ArrayLike<number>, offset?: number) => three5.Matrix3;
            toArray: {
              (): three5.Matrix3Tuple;
              <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
            };
            clone: () => three5.Matrix3;
          };
          matrixAutoUpdate: boolean;
          offset: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          repeat: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          center: {
            x: number;
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set: (x: number, y: number) => three5.Vector2;
            setScalar: (scalar: number) => three5.Vector2;
            setX: (x: number) => three5.Vector2;
            setY: (y: number) => three5.Vector2;
            setComponent: (index: number, value: number) => three5.Vector2;
            getComponent: (index: number) => number;
            clone: () => three5.Vector2;
            copy: (v: three5.Vector2Like) => three5.Vector2;
            add: (v: three5.Vector2Like) => three5.Vector2;
            addScalar: (s: number) => three5.Vector2;
            addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
            sub: (v: three5.Vector2Like) => three5.Vector2;
            subScalar: (s: number) => three5.Vector2;
            subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
            multiply: (v: three5.Vector2Like) => three5.Vector2;
            multiplyScalar: (scalar: number) => three5.Vector2;
            divide: (v: three5.Vector2Like) => three5.Vector2;
            divideScalar: (s: number) => three5.Vector2;
            applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
            min: (v: three5.Vector2Like) => three5.Vector2;
            max: (v: three5.Vector2Like) => three5.Vector2;
            clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
            clampScalar: (min: number, max: number) => three5.Vector2;
            clampLength: (min: number, max: number) => three5.Vector2;
            floor: () => three5.Vector2;
            ceil: () => three5.Vector2;
            round: () => three5.Vector2;
            roundToZero: () => three5.Vector2;
            negate: () => three5.Vector2;
            dot: (v: three5.Vector2Like) => number;
            cross: (v: three5.Vector2Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => three5.Vector2;
            angle: () => number;
            angleTo: (v: three5.Vector2) => number;
            distanceTo: (v: three5.Vector2Like) => number;
            distanceToSquared: (v: three5.Vector2Like) => number;
            manhattanDistanceTo: (v: three5.Vector2Like) => number;
            setLength: (length: number) => three5.Vector2;
            lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
            lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
            equals: (v: three5.Vector2Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
            toArray: {
              (array?: number[], offset?: number): number[];
              (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
              (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
            rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
            random: () => three5.Vector2;
            [Symbol.iterator]: () => Iterator<number>;
          };
          rotation: number;
          generateMipmaps: boolean;
          premultiplyAlpha: boolean;
          unpackAlignment: number;
          colorSpace: string;
          isRenderTargetTexture: boolean;
          isArrayTexture: boolean;
          userData: Record<string, any>;
          updateRanges: {
            start: number;
            count: number;
          }[];
          version: number;
          pmremVersion: number;
          needsUpdate: boolean;
          needsPMREMUpdate: boolean;
          renderTarget: /*elided*/any | null;
          onUpdate: ((texture: Texture) => void) | null;
          transformUv: (uv: three5.Vector2) => three5.Vector2;
          updateMatrix: () => void;
          addUpdateRange: (start: number, count: number) => void;
          clearUpdateRanges: () => void;
          clone: () => three5.CubeTexture;
          copy: (source: Texture) => three5.CubeTexture;
          setValues: (values: three5.TextureParameters) => void;
          toJSON: (meta?: string | {}) => three5.TextureJSON;
          dispose: () => void;
          addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.CubeTexture>) => void;
          hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.CubeTexture>) => boolean;
          removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
            dispose: {};
          }[T], T, three5.CubeTexture>) => void;
          dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
            dispose: {};
          }[T]) => void;
        }[];
        mapping: three5.AnyMapping;
        channel: number;
        wrapS: three5.Wrapping;
        wrapT: three5.Wrapping;
        anisotropy: number;
        internalFormat: three5.PixelFormatGPU | null;
        matrix: {
          readonly isMatrix3: true;
          elements: [n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number];
          set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => three5.Matrix3;
          identity: () => three5.Matrix3;
          copy: (m: three5.Matrix3) => three5.Matrix3;
          extractBasis: (xAxis: three5.Vector3, yAxis: three5.Vector3, zAxis: three5.Vector3) => three5.Matrix3;
          setFromMatrix4: (m: three5.Matrix4) => three5.Matrix3;
          multiply: (m: three5.Matrix3) => three5.Matrix3;
          premultiply: (m: three5.Matrix3) => three5.Matrix3;
          multiplyMatrices: (a: three5.Matrix3, b: three5.Matrix3) => three5.Matrix3;
          multiplyScalar: (s: number) => three5.Matrix3;
          determinant: () => number;
          invert: () => three5.Matrix3;
          transpose: () => three5.Matrix3;
          getNormalMatrix: (matrix4: three5.Matrix4) => three5.Matrix3;
          transposeIntoArray: (r: number[]) => three5.Matrix3;
          setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => three5.Matrix3;
          scale: (sx: number, sy: number) => three5.Matrix3;
          rotate: (theta: number) => three5.Matrix3;
          translate: (tx: number, ty: number) => three5.Matrix3;
          makeTranslation: {
            (v: three5.Vector2): three5.Matrix3;
            (x: number, y: number): three5.Matrix3;
          };
          makeRotation: (theta: number) => three5.Matrix3;
          makeScale: (x: number, y: number) => three5.Matrix3;
          equals: (matrix: three5.Matrix3) => boolean;
          fromArray: (array: ArrayLike<number>, offset?: number) => three5.Matrix3;
          toArray: {
            (): three5.Matrix3Tuple;
            <TArray extends ArrayLike<number>>(array: TArray, offset?: number): TArray;
          };
          clone: () => three5.Matrix3;
        };
        matrixAutoUpdate: boolean;
        offset: {
          x: number;
          y: number;
          width: number;
          height: number;
          readonly isVector2: true;
          set: (x: number, y: number) => three5.Vector2;
          setScalar: (scalar: number) => three5.Vector2;
          setX: (x: number) => three5.Vector2;
          setY: (y: number) => three5.Vector2;
          setComponent: (index: number, value: number) => three5.Vector2;
          getComponent: (index: number) => number;
          clone: () => three5.Vector2;
          copy: (v: three5.Vector2Like) => three5.Vector2;
          add: (v: three5.Vector2Like) => three5.Vector2;
          addScalar: (s: number) => three5.Vector2;
          addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
          sub: (v: three5.Vector2Like) => three5.Vector2;
          subScalar: (s: number) => three5.Vector2;
          subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          multiply: (v: three5.Vector2Like) => three5.Vector2;
          multiplyScalar: (scalar: number) => three5.Vector2;
          divide: (v: three5.Vector2Like) => three5.Vector2;
          divideScalar: (s: number) => three5.Vector2;
          applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
          min: (v: three5.Vector2Like) => three5.Vector2;
          max: (v: three5.Vector2Like) => three5.Vector2;
          clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
          clampScalar: (min: number, max: number) => three5.Vector2;
          clampLength: (min: number, max: number) => three5.Vector2;
          floor: () => three5.Vector2;
          ceil: () => three5.Vector2;
          round: () => three5.Vector2;
          roundToZero: () => three5.Vector2;
          negate: () => three5.Vector2;
          dot: (v: three5.Vector2Like) => number;
          cross: (v: three5.Vector2Like) => number;
          lengthSq: () => number;
          length: () => number;
          manhattanLength: () => number;
          normalize: () => three5.Vector2;
          angle: () => number;
          angleTo: (v: three5.Vector2) => number;
          distanceTo: (v: three5.Vector2Like) => number;
          distanceToSquared: (v: three5.Vector2Like) => number;
          manhattanDistanceTo: (v: three5.Vector2Like) => number;
          setLength: (length: number) => three5.Vector2;
          lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
          lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
          equals: (v: three5.Vector2Like) => boolean;
          fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
          toArray: {
            (array?: number[], offset?: number): number[];
            (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
          };
          fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
          rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
          random: () => three5.Vector2;
          [Symbol.iterator]: () => Iterator<number>;
        };
        repeat: {
          x: number;
          y: number;
          width: number;
          height: number;
          readonly isVector2: true;
          set: (x: number, y: number) => three5.Vector2;
          setScalar: (scalar: number) => three5.Vector2;
          setX: (x: number) => three5.Vector2;
          setY: (y: number) => three5.Vector2;
          setComponent: (index: number, value: number) => three5.Vector2;
          getComponent: (index: number) => number;
          clone: () => three5.Vector2;
          copy: (v: three5.Vector2Like) => three5.Vector2;
          add: (v: three5.Vector2Like) => three5.Vector2;
          addScalar: (s: number) => three5.Vector2;
          addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
          sub: (v: three5.Vector2Like) => three5.Vector2;
          subScalar: (s: number) => three5.Vector2;
          subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          multiply: (v: three5.Vector2Like) => three5.Vector2;
          multiplyScalar: (scalar: number) => three5.Vector2;
          divide: (v: three5.Vector2Like) => three5.Vector2;
          divideScalar: (s: number) => three5.Vector2;
          applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
          min: (v: three5.Vector2Like) => three5.Vector2;
          max: (v: three5.Vector2Like) => three5.Vector2;
          clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
          clampScalar: (min: number, max: number) => three5.Vector2;
          clampLength: (min: number, max: number) => three5.Vector2;
          floor: () => three5.Vector2;
          ceil: () => three5.Vector2;
          round: () => three5.Vector2;
          roundToZero: () => three5.Vector2;
          negate: () => three5.Vector2;
          dot: (v: three5.Vector2Like) => number;
          cross: (v: three5.Vector2Like) => number;
          lengthSq: () => number;
          length: () => number;
          manhattanLength: () => number;
          normalize: () => three5.Vector2;
          angle: () => number;
          angleTo: (v: three5.Vector2) => number;
          distanceTo: (v: three5.Vector2Like) => number;
          distanceToSquared: (v: three5.Vector2Like) => number;
          manhattanDistanceTo: (v: three5.Vector2Like) => number;
          setLength: (length: number) => three5.Vector2;
          lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
          lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
          equals: (v: three5.Vector2Like) => boolean;
          fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
          toArray: {
            (array?: number[], offset?: number): number[];
            (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
          };
          fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
          rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
          random: () => three5.Vector2;
          [Symbol.iterator]: () => Iterator<number>;
        };
        center: {
          x: number;
          y: number;
          width: number;
          height: number;
          readonly isVector2: true;
          set: (x: number, y: number) => three5.Vector2;
          setScalar: (scalar: number) => three5.Vector2;
          setX: (x: number) => three5.Vector2;
          setY: (y: number) => three5.Vector2;
          setComponent: (index: number, value: number) => three5.Vector2;
          getComponent: (index: number) => number;
          clone: () => three5.Vector2;
          copy: (v: three5.Vector2Like) => three5.Vector2;
          add: (v: three5.Vector2Like) => three5.Vector2;
          addScalar: (s: number) => three5.Vector2;
          addVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          addScaledVector: (v: three5.Vector2Like, s: number) => three5.Vector2;
          sub: (v: three5.Vector2Like) => three5.Vector2;
          subScalar: (s: number) => three5.Vector2;
          subVectors: (a: three5.Vector2Like, b: three5.Vector2Like) => three5.Vector2;
          multiply: (v: three5.Vector2Like) => three5.Vector2;
          multiplyScalar: (scalar: number) => three5.Vector2;
          divide: (v: three5.Vector2Like) => three5.Vector2;
          divideScalar: (s: number) => three5.Vector2;
          applyMatrix3: (m: three5.Matrix3) => three5.Vector2;
          min: (v: three5.Vector2Like) => three5.Vector2;
          max: (v: three5.Vector2Like) => three5.Vector2;
          clamp: (min: three5.Vector2Like, max: three5.Vector2Like) => three5.Vector2;
          clampScalar: (min: number, max: number) => three5.Vector2;
          clampLength: (min: number, max: number) => three5.Vector2;
          floor: () => three5.Vector2;
          ceil: () => three5.Vector2;
          round: () => three5.Vector2;
          roundToZero: () => three5.Vector2;
          negate: () => three5.Vector2;
          dot: (v: three5.Vector2Like) => number;
          cross: (v: three5.Vector2Like) => number;
          lengthSq: () => number;
          length: () => number;
          manhattanLength: () => number;
          normalize: () => three5.Vector2;
          angle: () => number;
          angleTo: (v: three5.Vector2) => number;
          distanceTo: (v: three5.Vector2Like) => number;
          distanceToSquared: (v: three5.Vector2Like) => number;
          manhattanDistanceTo: (v: three5.Vector2Like) => number;
          setLength: (length: number) => three5.Vector2;
          lerp: (v: three5.Vector2Like, alpha: number) => three5.Vector2;
          lerpVectors: (v1: three5.Vector2Like, v2: three5.Vector2Like, alpha: number) => three5.Vector2;
          equals: (v: three5.Vector2Like) => boolean;
          fromArray: (array: number[] | ArrayLike<number>, offset?: number) => three5.Vector2;
          toArray: {
            (array?: number[], offset?: number): number[];
            (array?: three5.Vector2Tuple, offset?: 0): three5.Vector2Tuple;
            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
          };
          fromBufferAttribute: (attribute: three5.BufferAttribute, index: number) => three5.Vector2;
          rotateAround: (center: three5.Vector2Like, angle: number) => three5.Vector2;
          random: () => three5.Vector2;
          [Symbol.iterator]: () => Iterator<number>;
        };
        rotation: number;
        premultiplyAlpha: boolean;
        unpackAlignment: number;
        colorSpace: string;
        isRenderTargetTexture: boolean;
        isArrayTexture: boolean;
        userData: Record<string, any>;
        updateRanges: {
          start: number;
          count: number;
        }[];
        version: number;
        pmremVersion: number;
        needsUpdate: boolean;
        needsPMREMUpdate: boolean;
        renderTarget: /*elided*/any | null;
        onUpdate: ((texture: Texture) => void) | null;
        transformUv: (uv: three5.Vector2) => three5.Vector2;
        updateMatrix: () => void;
        addUpdateRange: (start: number, count: number) => void;
        clearUpdateRanges: () => void;
        clone: () => three5.DepthTexture;
        copy: (source: Texture) => three5.DepthTexture;
        setValues: (values: three5.TextureParameters) => void;
        toJSON: (meta?: string | {}) => three5.TextureJSON;
        dispose: () => void;
        addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.DepthTexture>) => void;
        hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.DepthTexture>) => boolean;
        removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
          dispose: {};
        }[T], T, three5.DepthTexture>) => void;
        dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
          dispose: {};
        }[T]) => void;
      } | null;
      setSize: (width: number, height: number, depth?: number) => void;
      clone: () => three5.RenderTarget<Texture>;
      copy: (source: three5.RenderTarget) => three5.RenderTarget<Texture>;
      dispose: () => void;
      addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.RenderTarget<Texture>>) => void;
      hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.RenderTarget<Texture>>) => boolean;
      removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
        dispose: {};
      }[T], T, three5.RenderTarget<Texture>>) => void;
      dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
        dispose: {};
      }[T]) => void;
    } | null;
    onUpdate: ((texture: Texture) => void) | null;
    transformUv: (uv: three5.Vector2) => three5.Vector2;
    updateMatrix: () => void;
    addUpdateRange: (start: number, count: number) => void;
    clearUpdateRanges: () => void;
    clone: () => Texture;
    copy: (source: Texture) => Texture;
    setValues: (values: three5.TextureParameters) => void;
    toJSON: (meta?: string | {}) => three5.TextureJSON;
    dispose: () => void;
    addEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
      dispose: {};
    }[T], T, Texture>) => void;
    hasEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
      dispose: {};
    }[T], T, Texture>) => boolean;
    removeEventListener: <T extends "dispose">(type: T, listener: three5.EventListener<{
      dispose: {};
    }[T], T, Texture>) => void;
    dispatchEvent: <T extends "dispose">(event: three5.BaseEvent<T> & {
      dispose: {};
    }[T]) => void;
  };
  isLoading: boolean;
  error: unknown;
};
type __VLS_Slots$27 = {} & {
  default?: (props: typeof __VLS_1) => any;
};
declare const __VLS_base$27: vue0.DefineComponent<__VLS_Props$4, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  loaded: (result: Texture) => any;
  error: (error: unknown) => any;
}, string, vue0.PublicProps, Readonly<__VLS_Props$4> & Readonly<{
  onLoaded?: ((result: Texture) => any) | undefined;
  onError?: ((error: unknown) => any) | undefined;
}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$49: __VLS_WithSlots$27<typeof __VLS_base$27, __VLS_Slots$27>;
declare const _default$81: typeof __VLS_export$49;
type __VLS_WithSlots$27<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/loaders/useProgress.d.ts
declare function useProgress(): Promise<{
  hasFinishLoading: Ref<boolean>;
  progress: Ref<number>;
  items: Ref<string[]>;
}>;
//#endregion
//#region src/core/loaders/useVideoTexture.d.ts
interface VideoTextureProps extends HTMLVideoElement {
  unsuspend?: 'canplay' | 'canplaythrough' | 'loadstart' | 'loadedmetadata';
  start?: boolean;
}
/**
 * Composable for loading video textures.
 *
 * ```ts
 * import { ref } from 'vue'
 * import { useVideoTexture } from '@tresjs/cientos'
 * import MyVideo from 'MyVideo.mp4'
 *
 * const texture = ref()
 * texture.value = await useVideoTexture(MyVideo)
 * ```
 * Then you can use the texture in your material.
 *
 * ```vue
 * <TresMeshBasicMaterial :map="texture" />
 * ```
 * @see https://threejs.org/docs/index.html?q=video#api/en/textures/VideoTexture
 * @export
 * @param {HTMLVideoElement} src
 * @return {VideoTexture}  {VideoTexture}
 */
declare function useVideoTexture(src: string | MediaStream, options?: Partial<VideoTextureProps>): Promise<void | VideoTexture>;
//#endregion
//#region src/core/loaders/useFBX/index.d.ts
interface UseFBXOptions {
  /**
   * A traverse function applied to the scene upon loading the model.
   * @type {Function}
   */
  traverse?: (child: TresObject) => void;
}
/**
 * Vue composable for loading FBX models in TresJS
 *
 * @remarks
 * This composable uses Three.js FBXLoader under the hood to load FBX 3D models.
 * The loaded model is automatically parsed and made available as a reactive state.
 *
 * @example
 * ```ts
 * const { state: model } = useFBX('/path/to/model.fbx')
 * ```
 *
 * @param {MaybeRef<string>} path - Path to the FBX model file
 * @returns {{ state: Group, isLoading: boolean, execute: () => Promise<void>, nodes: object, materials: object }} Object containing the model state, loading state, reload function, and parsed nodes/materials
 */
declare function useFBX(path: MaybeRef<string>, options?: UseFBXOptions): {
  state: Ref<Group | null>;
  isLoading: Ref<boolean>;
  execute: (delay?: number, ...args: any[]) => Promise<Group>;
  nodes: ComputedRef<Record<string, any>>;
  materials: ComputedRef<Record<string, any>>;
};
//#endregion
//#region src/core/loaders/useGLTF/index.d.ts
interface UseGLTFOptions {
  /**
   * Whether to use DRACO compression for loading the model
   * @type {boolean}
   */
  draco?: boolean;
  /**
   * Path to the DRACO decoder. Defaults to https://www.gstatic.com/draco/versioned/decoders/1.5.6/
   * @type {string}
   */
  decoderPath?: string;
  /**
   * A traverse function applied to the scene upon loading the model.
   * @type {Function}
   */
  traverse?: (child: TresObject) => void;
}
/**
 * Vue composable for loading GLTF models in TresJS
 *
 * @remarks
 * This composable uses Three.js GLTFLoader under the hood and supports DRACO compression.
 * When DRACO compression is enabled, it will use the specified decoder path or fallback to Google's CDN.
 *
 * @example
 * ```ts
 * const { state: model } = useGLTF('/path/to/model.glb', { draco: true })
 * ```
 *
 * @param {MaybeRef<string>} path - Path to the GLTF model file
 * @param {UseGLTFOptions} options - Options for loading the model
 * @returns {{ state: GLTF, isLoading: boolean, execute: () => Promise<void> }} Object containing the model state, loading state and reload function
 */
declare function useGLTF(path: MaybeRef<string>, options?: UseGLTFOptions): {
  state: Ref<GLTF | null>;
  isLoading: Ref<boolean>;
  execute: (delay?: number, ...args: any[]) => Promise<GLTF>;
  nodes: ComputedRef<Record<string, any>>;
  materials: ComputedRef<Record<string, any>>;
};
//#endregion
//#region src/core/loaders/useTexture/index.d.ts
declare function useTexture(path: MaybeRef<string>): _tresjs_core0.UseLoaderReturn<Texture, false>;
//#endregion
//#region src/core/loaders/useTextures/index.d.ts
/**
 * Composable that loads multiple textures at once
 *
 * @param paths - Array of paths to texture files
 * @returns Object containing textures, loading state, and error state
 */
declare function useTextures(paths: MaybeRef<string[]>): {
  textures: vue0.ComputedRef<Texture[]>;
  isLoading: vue0.ComputedRef<boolean>;
  error: vue0.ComputedRef<Error[] | null>;
};
//#endregion
//#region src/core/materials/customShaderMaterial/index.vue.d.ts
interface CustomShaderMaterialProps {
  baseMaterial: Fn;
  vertexShader?: string;
  fragmentShader?: string;
  silent?: boolean;
  uniforms?: {
    [uniform: string]: any;
  };
}
declare const __VLS_export$48: vue0.DefineComponent<CustomShaderMaterialProps, {
  instance: vue0.ShallowRef<null, null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<CustomShaderMaterialProps> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$15: typeof __VLS_export$48;
//#endregion
//#region src/core/materials/holographicMaterial/HolographicMaterialParameters.d.ts
interface HolographicMaterialParameters {
  time?: number;
  fresnelOpacity?: number;
  fresnelAmount?: number;
  scanlineSize?: number;
  hologramBrightness?: number;
  signalSpeed?: number;
  hologramColor?: Color;
  enableBlinking?: boolean;
  blinkFresnelOnly?: boolean;
  hologramOpacity?: number;
  blendMode?: Blending;
  side?: Side;
  depthTest?: boolean;
}
declare class HolographicMaterial extends ShaderMaterial {
  clock: Clock;
  /**
   * Create a HolographicMaterial.
   *
   * @param {object} parameters - The parameters to configure the material.
   * @param {number} [parameters.time] - The time uniform representing animation time.
   * @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.
   * @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.
   * @param {number} [parameters.scanlineSize] - The size of the scanline effect.
   * @param {number} [parameters.hologramBrightness] - The brightness of the hologram.
   * @param {number} [parameters.signalSpeed] - The speed of the signal effect.
   * @param {Color} [parameters.hologramColor] - The color of the hologram.
   * @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.
   * @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.
   * @param {number} [parameters.hologramOpacity] - The opacity of the hologram.
   * @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
   * @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,
   *  `THREE.BackSide`, or `THREE.DoubleSide`.
   * @param {boolean} [parameters.depthTest] - Enable or disable depthTest.
   */
  constructor(parameters?: HolographicMaterialParameters);
  update(): void;
}
//#endregion
//#region src/core/materials/holographicMaterial/index.vue.d.ts
type __VLS_Props$3 = {
  fresnelAmount?: number;
  fresnelOpacity?: number;
  blinkFresnelOnly?: boolean;
  enableBlinking?: boolean;
  enableAdditive?: boolean;
  hologramBrightness?: number;
  scanlineSize?: number;
  signalSpeed?: number;
  hologramOpacity?: number;
  hologramColor?: TresColor;
  side?: Side;
};
declare const __VLS_export$47: vue0.DefineComponent<__VLS_Props$3, {
  root: vue0.ShallowRef<any, any>;
  constructor: typeof HolographicMaterial;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<__VLS_Props$3> & Readonly<{}>, {
  side: Side;
  fresnelAmount: number;
  fresnelOpacity: number;
  blinkFresnelOnly: boolean;
  enableBlinking: boolean;
  enableAdditive: boolean;
  hologramBrightness: number;
  scanlineSize: number;
  signalSpeed: number;
  hologramOpacity: number;
  hologramColor: TresColor;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$27: typeof __VLS_export$47;
//#endregion
//#region src/core/materials/meshDiscardMaterial/index.vue.d.ts
declare const __VLS_export$46: vue0.DefineComponent<{}, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
declare const _default$42: typeof __VLS_export$46;
//#endregion
//#region src/core/materials/meshGlassMaterial/index.vue.d.ts
declare const __VLS_export$45: vue0.DefineComponent<{}, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
declare const _default$43: typeof __VLS_export$45;
//#endregion
//#region src/core/materials/meshReflectionMaterial/index.vue.d.ts
interface MeshReflectionMaterialProps {
  /** Length in pixels of one side of the square reflective textures. */
  resolution?: number;
  /** Overall strength of the reflection. */
  mix?: number;
  /** Strength of the sharp reflection on smooth surfaces. */
  sharpMix?: number;
  /** Sharp reflection can be faded out by depth  distance from the reflective surface. Performance note: if the value is greater than `0`, a depth texture will be created. */
  sharpDepthScale?: number;
  /** Sharp reflection depth falloff bias. */
  sharpDepthBias?: number;
  /** Sharp reflection depth falloff start. */
  sharpDepthEdgeMin?: number;
  /** Sharp reflection depth falloff end. */
  sharpDepthEdgeMax?: number;
  /** Strength of the blurred reflection on smooth surfaces. */
  blurMixSmooth?: number;
  /** Strength of the blurred reflection on rough surfaces. */
  blurMixRough?: number;
  /** Blurred reflection can spread out by depth  distance from the reflective surface. Performance note: if the value is greater than `0`, depth texture will be rendered. */
  blurDepthScale?: number;
  /** Blurred reflection depth spread bias. */
  blurDepthBias?: number;
  /** Blurred reflection depth spread start. */
  blurDepthEdgeMin?: number;
  /** Blurred reflection depth spread end. */
  blurDepthEdgeMax?: number;
  /** Size of the blur. If `[number, number]`, first number is width, second is height. Performance note: if other than `[0, 0]` or `0`, a blur texture will be rendered. */
  blurSize?: [number, number] | number;
  /** Texture for offsetting the reflection. */
  distortionMap?: Texture;
  /** Influence of `distortionMap`. */
  distortion?: number;
  /** Offsets the reflection. */
  reflectorOffset?: number;
  color?: TresColor;
  roughness?: number;
  metalness?: number;
  map?: Texture;
  lightMap?: Texture;
  lightMapIntensity?: number;
  aoMap?: Texture | null;
  aoMapIntensity?: number;
  emissive?: TresColor;
  emissiveIntensity?: number;
  emissiveMap?: Texture;
  bumpMap?: Texture;
  bumpScale?: number;
  normalMap?: Texture;
  normalMapType?: number;
  normalScale?: Vector2;
  displacementMap?: Texture;
  displacementScale?: number;
  displacementBias?: number;
  roughnessMap?: Texture | null;
  metalnessMap?: Texture | null;
  alphaMap?: Texture | null;
  envMap?: Texture | null;
  envMapRotation?: Euler;
  envMapIntensity?: number;
  wireframe?: boolean;
  wireframeLinewidth?: number;
  wireframeLinecap?: string;
  wireframeLinejoin?: string;
  flatShading?: boolean;
  fog?: boolean;
}
declare const __VLS_export$44: vue0.DefineComponent<MeshReflectionMaterialProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<MeshReflectionMaterialProps> & Readonly<{}>, {
  resolution: number;
  fog: boolean;
  color: TresColor;
  lightMapIntensity: number;
  aoMapIntensity: number;
  envMapRotation: Euler;
  wireframe: boolean;
  wireframeLinewidth: number;
  wireframeLinecap: string;
  wireframeLinejoin: string;
  mix: number;
  sharpMix: number;
  sharpDepthScale: number;
  sharpDepthBias: number;
  sharpDepthEdgeMin: number;
  sharpDepthEdgeMax: number;
  blurMixSmooth: number;
  blurMixRough: number;
  blurDepthScale: number;
  blurDepthBias: number;
  blurDepthEdgeMin: number;
  blurDepthEdgeMax: number;
  blurSize: [number, number] | number;
  distortion: number;
  reflectorOffset: number;
  roughness: number;
  metalness: number;
  emissive: TresColor;
  emissiveIntensity: number;
  bumpScale: number;
  normalMapType: number;
  normalScale: Vector2;
  displacementScale: number;
  displacementBias: number;
  roughnessMap: Texture | null;
  envMapIntensity: number;
  flatShading: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$44: typeof __VLS_export$44;
//#endregion
//#region src/core/materials/meshWobbleMaterial/index.vue.d.ts
type __VLS_Props$2 = {
  speed?: number;
  factor?: number;
};
declare const __VLS_export$43: vue0.DefineComponent<__VLS_Props$2, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<__VLS_Props$2> & Readonly<{}>, {
  speed: number;
  factor: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$45: typeof __VLS_export$43;
//#endregion
//#region src/core/materials/pointMaterial/material.d.ts
declare class PointMaterial extends PointsMaterial {
  constructor(props: PointsMaterialParameters);
}
//#endregion
//#region src/core/materials/pointMaterial/component.vue.d.ts
type __VLS_Props$1 = {
  sizeAttenuation?: boolean;
};
declare const __VLS_export$42: vue0.DefineComponent<__VLS_Props$1, {
  instance: vue0.ShallowRef<PointMaterial, PointMaterial>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<__VLS_Props$1> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$52: typeof __VLS_export$42;
//#endregion
//#region src/core/misc/BakeShadows.d.ts
declare const BakeShadows: vue0.DefineComponent<{}, void, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
//#endregion
//#region src/core/misc/LOD.vue.d.ts
interface LODProps {
  /**
   * The distances at which to display each level of detail.
   * There should be one `levels` value for each `LOD` child.
   */
  levels: number[];
  /**
  * Threshold used to avoid flickering at LOD boundaries, as a fraction of distance
  * @default 0.0
  */
  hysteresis?: number;
}
declare var __VLS_8$4: {};
type __VLS_Slots$26 = {} & {
  default?: (props: typeof __VLS_8$4) => any;
};
declare const __VLS_base$26: vue0.DefineComponent<LODProps, {
  instance: vue0.ShallowRef<LOD<Object3DEventMap>, LOD<Object3DEventMap>>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<LODProps> & Readonly<{}>, {
  hysteresis: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$41: __VLS_WithSlots$26<typeof __VLS_base$26, __VLS_Slots$26>;
declare const _default$32: typeof __VLS_export$41;
type __VLS_WithSlots$26<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/misc/html/HTML.vue.d.ts
interface HTMLProps {
  geometry?: any;
  material?: any;
  as?: string;
  transform?: boolean;
  portal?: Mutable<HTMLElement>;
  wrapperClass?: string;
  eps?: number;
  distanceFactor?: number;
  fullscreen?: boolean;
  center?: boolean;
  pointerEvents?: PointerEventsProperties;
  sprite?: boolean;
  zIndexRange?: Array<number>;
  occlude?: TresObject3D | null | (TresObject3D | null)[] | boolean | 'raycast' | 'blending';
}
type PointerEventsProperties = 'auto' | 'none' | 'visiblePainted' | 'visibleFill' | 'visibleStroke' | 'visible' | 'painted' | 'fill' | 'stroke' | 'all' | 'inherit';
declare const __VLS_base$25: vue0.DefineComponent<HTMLProps, {
  instance: vue0.Ref<TresObject3D | undefined, TresObject3D | undefined>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  onOcclude: (...args: any[]) => void;
}, string, vue0.PublicProps, Readonly<HTMLProps> & Readonly<{
  onOnOcclude?: ((...args: any[]) => any) | undefined;
}>, {
  transform: boolean;
  geometry: any;
  as: string;
  eps: number;
  pointerEvents: PointerEventsProperties;
  sprite: boolean;
  zIndexRange: Array<number>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$40: __VLS_WithSlots$25<typeof __VLS_base$25, __VLS_Slots>;
declare const _default$28: typeof __VLS_export$40;
type __VLS_WithSlots$25<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/misc/Stats.d.ts
declare const Stats: vue0.DefineComponent<vue0.ExtractPropTypes<{
  showPanel: {
    type: NumberConstructor;
    default: number;
  };
}>, void, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<vue0.ExtractPropTypes<{
  showPanel: {
    type: NumberConstructor;
    default: number;
  };
}>> & Readonly<{}>, {
  showPanel: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
//#endregion
//#region src/core/misc/StatsGl.d.ts
interface StatsGlProps {
  logsPerSecond?: number;
  samplesLog?: number;
  samplesGraph?: number;
  precision?: number;
  horizontal?: boolean;
  minimal?: boolean;
  mode?: number;
}
declare const StatsGl: vue0.DefineComponent<StatsGlProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<StatsGlProps> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
//#endregion
//#region src/core/misc/useGLTFExporter.d.ts
interface gltfExporterOptions {
  fileName?: string;
  trs?: boolean;
  onlyVisible?: boolean;
  binary?: boolean;
  maxTextureSize?: number;
  animations?: AnimationClip[];
  includeCustomExtensions?: boolean;
}
declare function useGLTFExporter(object3D: Object3D | Object3D[], options?: gltfExporterOptions): Promise<void>;
//#endregion
//#region src/core/misc/useIntersect.d.ts
type UseIntersectCallback = (isIntersected: boolean) => void;
declare function useIntersect<T extends Object3D>(onChange?: Ref<UseIntersectCallback> | UseIntersectCallback): {
  ref: vue0.ShallowRef<T | undefined, T | undefined>;
  intersect: vue0.ShallowRef<boolean, boolean>;
  off: () => void;
};
//#endregion
//#region src/core/shapes/Box.vue.d.ts
interface BoxProps$1 {
  /**
   * The width, height and depth of the box.
   * @default [1, 1, 1]
   * @type {number[]}
   * @memberof BoxProps
   * @see https://threejs.org/docs/#api/en/geometries/BoxGeometry
   *
   */
  args?: ConstructorParameters<typeof BoxGeometry>;
  /**
   * The color of the box.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof BoxProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$14: {};
type __VLS_Slots$25 = {} & {
  default?: (props: typeof __VLS_13$14) => any;
};
declare const __VLS_base$24: vue0.DefineComponent<BoxProps$1, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<BoxProps$1> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof BoxGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$39: __VLS_WithSlots$24<typeof __VLS_base$24, __VLS_Slots$25>;
declare const _default$6: typeof __VLS_export$39;
type __VLS_WithSlots$24<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/CatmullRomCurve3.vue.d.ts
type CurveType = 'centripetal' | 'chordal' | 'catmullrom';
type Points$2 = Array<Vector3 | [number, number, number]>;
interface CatmullRomCurve3Props {
  segments?: number;
  closed?: boolean;
  curveType?: CurveType;
  tension?: number;
  points: Points$2;
  vertexColors?: TresColor[] | undefined;
  color?: TresColor;
  lineWidth?: number;
  alphaToCoverage?: boolean;
  dashed?: boolean;
  dashSize?: number;
  dashScale?: number;
  dashOffset?: number;
  gapSize?: number;
  worldUnits?: boolean;
}
declare const __VLS_export$38: vue0.DefineComponent<CatmullRomCurve3Props, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<CatmullRomCurve3Props> & Readonly<{}>, {
  segments: number;
  closed: boolean;
  curveType: CurveType;
  tension: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$8: typeof __VLS_export$38;
//#endregion
//#region src/core/shapes/Circle.vue.d.ts
interface CircleProps {
  /**
   * The radius, segment, thetaStart, thetaLength of the circle.
   * @default [1, 32, 0, Math.PI * 2]
   * @type {any[]}
   * @memberof CircleProps
   * @see https://threejs.org/docs/#api/en/geometries/CircleGeometry
   */
  args?: ConstructorParameters<typeof CircleGeometry>;
  /**
   * The color of the circle.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof CircleProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$13: {};
type __VLS_Slots$24 = {} & {
  default?: (props: typeof __VLS_13$13) => any;
};
declare const __VLS_base$23: vue0.DefineComponent<CircleProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<CircleProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof CircleGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$37: __VLS_WithSlots$23<typeof __VLS_base$23, __VLS_Slots$24>;
declare const _default$9: typeof __VLS_export$37;
type __VLS_WithSlots$23<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Cone.vue.d.ts
interface ConeProps {
  /**
   * The radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength of the cone.
   * @default [1, 1, 12, 12, false, 0, Math.PI * 2]
   * @type {any[]}
   * @memberof ConeProps
   * @see https://threejs.org/docs/#api/en/geometries/ConeGeometry
   */
  args?: ConstructorParameters<typeof ConeGeometry>;
  /**
   * The color of the cone.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof ConeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$12: {};
type __VLS_Slots$23 = {} & {
  default?: (props: typeof __VLS_13$12) => any;
};
declare const __VLS_base$22: vue0.DefineComponent<ConeProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<ConeProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof ConeGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$36: __VLS_WithSlots$22<typeof __VLS_base$22, __VLS_Slots$23>;
declare const _default$11: typeof __VLS_export$36;
type __VLS_WithSlots$22<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/QuadraticBezierLine.vue.d.ts
interface QuadraticBezierLineProps {
  start: Vector3 | [number, number, number];
  end: Vector3 | [number, number, number];
  mid?: Vector3 | [number, number, number];
  segments?: number;
}
declare const __VLS_export$35: vue0.DefineComponent<QuadraticBezierLineProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<QuadraticBezierLineProps> & Readonly<{}>, {
  segments: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$56: typeof __VLS_export$35;
//#endregion
//#region src/core/shapes/CubicBezierLine.vue.d.ts
interface CubicBezierLineProps {
  start: Vector3 | [number, number, number];
  end: Vector3 | [number, number, number];
  midA: Vector3 | [number, number, number];
  midB: Vector3 | [number, number, number];
  segments?: number;
}
declare const __VLS_export$34: vue0.DefineComponent<CubicBezierLineProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<CubicBezierLineProps> & Readonly<{}>, {
  segments: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$14: typeof __VLS_export$34;
//#endregion
//#region src/core/shapes/Cylinder.vue.d.ts
interface CylinderProps {
  /**
   * The radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength of the cylinder.
   * @default [1, 1, 1, 32, 1, false, 0, Math.PI * 2]
   * @type {any[]}
   * @memberof CylinderProps
   * @see https://threejs.org/docs/#api/en/geometries/CylinderGeometry
   */
  args?: ConstructorParameters<typeof CylinderGeometry>;
  /**
   * The color of the cylinder.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof CylinderProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$11: {};
type __VLS_Slots$22 = {} & {
  default?: (props: typeof __VLS_13$11) => any;
};
declare const __VLS_base$21: vue0.DefineComponent<CylinderProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<CylinderProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof CylinderGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$33: __VLS_WithSlots$21<typeof __VLS_base$21, __VLS_Slots$22>;
declare const _default$16: typeof __VLS_export$33;
type __VLS_WithSlots$21<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Dodecahedron.vue.d.ts
interface DodecahedronProps {
  /**
   * The radius and detail of the dodecahedron.
   * @default [1, 0]
   * @type {number[]}
   * @memberof DodecahedronProps
   * @see https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry
   */
  args?: ConstructorParameters<typeof DodecahedronGeometry>;
  /**
   * The color of the dodecahedron.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof DodecahedronProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$10: {};
type __VLS_Slots$21 = {} & {
  default?: (props: typeof __VLS_13$10) => any;
};
declare const __VLS_base$20: vue0.DefineComponent<DodecahedronProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<DodecahedronProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof DodecahedronGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$32: __VLS_WithSlots$20<typeof __VLS_base$20, __VLS_Slots$21>;
declare const _default$17: typeof __VLS_export$32;
type __VLS_WithSlots$20<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Icosahedron.vue.d.ts
interface IcosahedronProps {
  /**
   * The radius and detail of the icosahedron.
   * @default [1, 0]
   * @type {number[]}
   * @memberof IcosahedronProps
   * @see https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry
   */
  args?: ConstructorParameters<typeof IcosahedronGeometry>;
  /**
   * The color of the icosahedron.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof IcosahedronProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$9: {};
type __VLS_Slots$20 = {} & {
  default?: (props: typeof __VLS_13$9) => any;
};
declare const __VLS_base$19: vue0.DefineComponent<IcosahedronProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<IcosahedronProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof IcosahedronGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$31: __VLS_WithSlots$19<typeof __VLS_base$19, __VLS_Slots$20>;
declare const _default$29: typeof __VLS_export$31;
type __VLS_WithSlots$19<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Line2.vue.d.ts
type Points$1 = (Vector3 | Vector2 | [number, number, number] | [number, number] | number)[];
type VertexColors = Array<TresColor>;
interface LineProps {
  points: Points$1;
  vertexColors?: VertexColors | null;
  color?: TresColor;
  lineWidth?: number;
  worldUnits?: boolean;
  alphaToCoverage?: boolean;
  dashed?: boolean;
  dashSize?: number;
  gapSize?: number;
  dashScale?: number;
  dashOffset?: number;
}
declare const __VLS_export$30: vue0.DefineComponent<LineProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<LineProps> & Readonly<{}>, {
  color: TresColor;
  vertexColors: VertexColors | null;
  alphaToCoverage: boolean;
  lineWidth: number;
  dashed: boolean;
  dashSize: number;
  dashScale: number;
  dashOffset: number;
  gapSize: number;
  worldUnits: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$36: typeof __VLS_export$30;
//#endregion
//#region src/core/shapes/Octahedron.vue.d.ts
interface OctahedronProps {
  /**
   * The radius and detail of the octahedron.
   * @default [1, 0]
   * @type {number[]}
   * @memberof OctahedronProps
   * @see https://threejs.org/docs/#api/en/geometries/OctahedronGeometry
   */
  args?: ConstructorParameters<typeof OctahedronGeometry>;
  /**
   * The color of the octahedron.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof OctahedronProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$8: {};
type __VLS_Slots$19 = {} & {
  default?: (props: typeof __VLS_13$8) => any;
};
declare const __VLS_base$18: vue0.DefineComponent<OctahedronProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<OctahedronProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof OctahedronGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$29: __VLS_WithSlots$18<typeof __VLS_base$18, __VLS_Slots$19>;
declare const _default$48: typeof __VLS_export$29;
type __VLS_WithSlots$18<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Plane.vue.d.ts
interface PlaneProps {
  /**
   * The width, height, widthSegments and heightSegments of the plane.
   * @default [1, 1, 1, 1]
   * @type {number[]}
   * @memberof PlaneProps
   * @see https://threejs.org/docs/#api/en/geometries/PlaneGeometry
   */
  args?: ConstructorParameters<typeof PlaneGeometry>;
  /**
   * The color of the plane.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof PlaneProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$7: {};
type __VLS_Slots$18 = {} & {
  default?: (props: typeof __VLS_13$7) => any;
};
declare const __VLS_base$17: vue0.DefineComponent<PlaneProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<PlaneProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof PlaneGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$28: __VLS_WithSlots$17<typeof __VLS_base$17, __VLS_Slots$18>;
declare const _default$51: typeof __VLS_export$28;
type __VLS_WithSlots$17<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Ring.vue.d.ts
interface RingProps {
  /**
   * The innerRadius, outerRadius, thetaSegments, phiSegments, tethaStart, thetaLength of the ring.
   * @default [0.5, 1, 32, 1, 0, Math.PI * 2]
   * @type {number[]}
   * @memberof RingProps
   * @see https://threejs.org/docs/#api/en/geometries/RingGeometry
   */
  args?: ConstructorParameters<typeof RingGeometry>;
  /**
   * The color of the ring.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof RingProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$6: {};
type __VLS_Slots$17 = {} & {
  default?: (props: typeof __VLS_13$6) => any;
};
declare const __VLS_base$16: vue0.DefineComponent<RingProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<RingProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof RingGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$27: __VLS_WithSlots$16<typeof __VLS_base$16, __VLS_Slots$17>;
declare const _default$59: typeof __VLS_export$27;
type __VLS_WithSlots$16<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/RoundedBox.vue.d.ts
interface BoxProps {
  /**
   * The width, height, depth, segments and radius.
   * @default [1, 1, 1, 2, 0.1]
   * @type {number[]}
   * @memberof BoxProps
   * @see https://github.com/mrdoob/three.js/blob/master/examples/jsm/geometries/RoundedBoxGeometry.js
   *
   */
  args?: ConstructorParameters<typeof BoxGeometry>;
  /**
   * The color of the box.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof BoxProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$5: {};
type __VLS_Slots$16 = {} & {
  default?: (props: typeof __VLS_13$5) => any;
};
declare const __VLS_base$15: vue0.DefineComponent<BoxProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<BoxProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof BoxGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$26: __VLS_WithSlots$15<typeof __VLS_base$15, __VLS_Slots$16>;
declare const _default$60: typeof __VLS_export$26;
type __VLS_WithSlots$15<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/ScreenQuad.vue.d.ts
declare var __VLS_8$3: {};
type __VLS_Slots$15 = {} & {
  default?: (props: typeof __VLS_8$3) => any;
};
declare const __VLS_base$14: vue0.DefineComponent<{}, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue0.ComponentProvideOptions, true, {}, any>;
declare const __VLS_export$25: __VLS_WithSlots$14<typeof __VLS_base$14, __VLS_Slots$15>;
declare const _default$62: typeof __VLS_export$25;
type __VLS_WithSlots$14<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Sphere.vue.d.ts
interface SphereProps {
  /**
   * The radius, widthSegments, heightSegments, phiStart phiLength,
   * thetaStart and thetaLength of the sphere.
   * @default [2, 32, 16, 0, Math.PI * 2, 0, Math.PI]
   * @type {number[]}
   * @memberof SphereProps
   * @see https://threejs.org/docs/#api/en/geometries/SphereGeometry
   */
  args?: ConstructorParameters<typeof SphereGeometry>;
  /**
   * The color of the sphere.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof SphereProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$4: {};
type __VLS_Slots$14 = {} & {
  default?: (props: typeof __VLS_13$4) => any;
};
declare const __VLS_base$13: vue0.DefineComponent<SphereProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SphereProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof SphereGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$24: __VLS_WithSlots$13<typeof __VLS_base$13, __VLS_Slots$14>;
declare const _default$70: typeof __VLS_export$24;
type __VLS_WithSlots$13<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Superformula.vue.d.ts
type Float3 = [number, number, number];
interface SuperFormulaProps {
  /**
   * Number of horizontal mesh segments
   */
  widthSegments?: number;
  /**
   * Number of vertical mesh segments
   */
  heightSegments?: number;
  /**
   * The 3D Superformula is the spherical product of 2 2D superformula curves: here called curves "A" and "B".
   * Number of radial arms/ripples of A, corresponding to "m" [in this article.](https://en.wikipedia.org/wiki/Superformula)
   */
  numArmsA?: number;
  /**
   * A's 3 exponents
   */
  expA?: Float3;
  /**
   * For B, number of radial arms/ripples
   */
  numArmsB?: number;
  /**
   * B's 3 exponents
   */
  expB?: Float3;
  /**
   * If no material is provided, a color for the default material
   */
  color?: TresColor;
}
declare var __VLS_8$2: {};
type __VLS_Slots$13 = {} & {
  default?: (props: typeof __VLS_8$2) => any;
};
declare const __VLS_base$12: vue0.DefineComponent<SuperFormulaProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SuperFormulaProps> & Readonly<{}>, {
  color: TresColor;
  widthSegments: number;
  heightSegments: number;
  numArmsA: number;
  expA: Float3;
  numArmsB: number;
  expB: Float3;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$23: __VLS_WithSlots$12<typeof __VLS_base$12, __VLS_Slots$13>;
declare const _default$73: typeof __VLS_export$23;
type __VLS_WithSlots$12<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Tetrahedron.vue.d.ts
interface TetrahedronProps {
  /**
   * The radius and detail of the tetrahedron.
   * @default [1, 0]
   * @type {number[]}
   * @memberof TetrahedronProps
   * @see https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry
   */
  args?: ConstructorParameters<typeof TetrahedronGeometry>;
  /**
   * The color of the tetrahedron.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof TetrahedronProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$3: {};
type __VLS_Slots$12 = {} & {
  default?: (props: typeof __VLS_13$3) => any;
};
declare const __VLS_base$11: vue0.DefineComponent<TetrahedronProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<TetrahedronProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof TetrahedronGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$22: __VLS_WithSlots$11<typeof __VLS_base$11, __VLS_Slots$12>;
declare const _default$74: typeof __VLS_export$22;
type __VLS_WithSlots$11<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Torus.vue.d.ts
interface TorusProps {
  /**
   * The radius, tube, radialSegments, tubularSegments, arc of the torus.
   * @default [1, 1, 16, 80, Math.PI * 2]
   * @type {number[]}
   * @memberof TorusProps
   * @see https://threejs.org/docs/#api/en/geometries/TorusGeometry
   */
  args?: ConstructorParameters<typeof TorusGeometry>;
  /**
   * The color of the torus.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof TorusProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$2: {};
type __VLS_Slots$11 = {} & {
  default?: (props: typeof __VLS_13$2) => any;
};
declare const __VLS_base$10: vue0.DefineComponent<TorusProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<TorusProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof TorusGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$21: __VLS_WithSlots$10<typeof __VLS_base$10, __VLS_Slots$11>;
declare const _default$76: typeof __VLS_export$21;
type __VLS_WithSlots$10<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/TorusKnot.vue.d.ts
interface TorusKnotProps {
  /**
   * The radius, tube, radialSegments, tubularSegments and p, q of the torus knot.
   * @default [1, 0.4, 64, 8, 2, 3]
   * @type {number[]}
   * @memberof TorusKnotProps
   * @see https://threejs.org/docs/#api/en/geometries/TorusKnotGeometry
   */
  args?: ConstructorParameters<typeof TorusKnotGeometry>;
  /**
   * The color of the torus knot.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof TorusKnotProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13$1: {};
type __VLS_Slots$10 = {} & {
  default?: (props: typeof __VLS_13$1) => any;
};
declare const __VLS_base$9: vue0.DefineComponent<TorusKnotProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<TorusKnotProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof TorusKnotGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$20: __VLS_WithSlots$9<typeof __VLS_base$9, __VLS_Slots$10>;
declare const _default$77: typeof __VLS_export$20;
type __VLS_WithSlots$9<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/shapes/Tube.vue.d.ts
interface TubeProps {
  /**
   * The curve, segments, radius, radialSegments, closed.
   * @default [new QuadraticBezierCurve3(new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0)), 20, 0.2, 8, false]
   * @type {TubeGeometryParams}
   * @memberof TubeProps
   * @see https://threejs.org/docs/#api/en/geometries/TubeGeometry
   */
  args?: ConstructorParameters<typeof TubeGeometry>;
  /**
   * The color of the tube.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof TubeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  color?: TresColor;
}
declare var __VLS_13: {};
type __VLS_Slots$9 = {} & {
  default?: (props: typeof __VLS_13) => any;
};
declare const __VLS_base$8: vue0.DefineComponent<TubeProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<TubeProps> & Readonly<{}>, {
  color: TresColor;
  args: ConstructorParameters<typeof TubeGeometry>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$19: __VLS_WithSlots$8<typeof __VLS_base$8, __VLS_Slots$9>;
declare const _default$79: typeof __VLS_export$19;
type __VLS_WithSlots$8<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/AccumulativeShadows/component.vue.d.ts
interface AccumulativeShadowsProps {
  /** Whether shadow creation only happens once (resets after props change), false */
  once?: boolean;
  /** Whether shadows accumulate progressively over several frames, true */
  accumulate?: boolean;
  /**
   * Number of frames to render. More yields cleaner results but takes more time.
   * If `accumulate && once`, 1 frame will be consumed every update for `frames` updates.
   * Otherwise, `frames` frames are consumed for every update.
   * 40
   */
  frames?: number;
  /** If `accumulate`, controls the refresh ratio, 100 */
  blend?: number;
  /** If less than `Infinity`, limits the amount of frames rendered. Use this to increase performance once a movable scene has settled, Infinity */
  limit?: number;
  /** Scale of the plane, 10 */
  scale?: number;
  /** Opacity of the plane, 1 */
  opacity?: number;
  /** Discards alpha pixels, 0.65 */
  alphaTest?: number;
  /** Shadow color, black */
  color?: ColorRepresentation;
  /** Colorblend, amount of `color` in shadow, 0 is black, 2 */
  colorBlend?: number;
  /** Buffer resolution, 1024 */
  resolution?: number;
  /** Texture tonemapping, true */
  toneMapped?: boolean;
}
declare var __VLS_15: {};
type __VLS_Slots$8 = {} & {
  default?: (props: typeof __VLS_15) => any;
};
declare const __VLS_base$7: vue0.DefineComponent<AccumulativeShadowsProps, {
  instance: vue0.ShallowRef<Group<three5.Object3DEventMap> | undefined, Group<three5.Object3DEventMap> | undefined>;
  update: () => void;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<AccumulativeShadowsProps> & Readonly<{}>, {
  alphaTest: number;
  frames: number;
  resolution: number;
  scale: number;
  color: ColorRepresentation;
  toneMapped: boolean;
  opacity: number;
  once: boolean;
  accumulate: boolean;
  blend: number;
  limit: number;
  colorBlend: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$18: __VLS_WithSlots$7<typeof __VLS_base$7, __VLS_Slots$8>;
declare const _default: typeof __VLS_export$18;
type __VLS_WithSlots$7<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Align.vue.d.ts
interface AlignCallbackOptions {
  /** The next parent above <Align /> */
  parent: Object3D<Object3DEventMap>;
  /** The outmost container group of the <Align/> component */
  container: Group;
  width: number;
  height: number;
  depth: number;
  boundingBox: Box3;
  boundingSphere: Sphere;
  center: Vector3;
  verticalAlignment: number;
  horizontalAlignment: number;
  depthAlignment: number;
}
interface AlignProps {
  top?: boolean;
  right?: boolean;
  bottom?: boolean;
  left?: boolean;
  front?: boolean;
  back?: boolean;
  /** Disable all axes */
  disable?: boolean;
  /** Disable x-axis alignment */
  disableX?: boolean;
  /** Disable y-axis alignment */
  disableY?: boolean;
  /** Disable z-axis alignment */
  disableZ?: boolean;
  /** See https://threejs.org/docs/index.html?q=box3#api/en/math/Box3.setFromObject */
  precise?: boolean;
  /** Optional cacheKey to keep the component from recalculating on every render */
  cacheKey?: MaybeRefOrGetter<any>;
}
declare function update(): void;
declare var __VLS_22$1: {};
type __VLS_Slots$7 = {} & {
  default?: (props: typeof __VLS_22$1) => any;
};
declare const __VLS_base$6: vue0.DefineComponent<AlignProps, {
  instance: vue0.ShallowRef<Group<Object3DEventMap> | undefined, Group<Object3DEventMap> | undefined>;
  update: typeof update;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {
  update: (props: AlignCallbackOptions) => void;
  change: (props: AlignCallbackOptions) => void;
}, string, vue0.PublicProps, Readonly<AlignProps> & Readonly<{
  onUpdate?: ((props: AlignCallbackOptions) => any) | undefined;
  onChange?: ((props: AlignCallbackOptions) => any) | undefined;
}>, {
  precise: boolean;
  cacheKey: MaybeRefOrGetter<any>;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$17: __VLS_WithSlots$6<typeof __VLS_base$6, __VLS_Slots$7>;
declare const _default$1: typeof __VLS_export$17;
type __VLS_WithSlots$6<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Backdrop.vue.d.ts
interface BackdropProps {
  floor?: number;
  segments?: number;
  receiveShadow?: boolean;
}
declare var __VLS_20: {};
type __VLS_Slots$6 = {} & {
  default?: (props: typeof __VLS_20) => any;
};
declare const __VLS_base$5: vue0.DefineComponent<BackdropProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<BackdropProps> & Readonly<{}>, {
  segments: number;
  floor: number;
  receiveShadow: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$16: __VLS_WithSlots$5<typeof __VLS_base$5, __VLS_Slots$6>;
declare const _default$3: typeof __VLS_export$16;
type __VLS_WithSlots$5<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Bounds/Bounds.d.ts
interface BoundsControlsProto {
  update: () => void;
  target: Vector3;
  maxDistance: number;
  addEventListener: (event: string, callback: (event: any) => void) => void;
  removeEventListener: (event: string, callback: (event: any) => void) => void;
}
interface OnLookAtCallbackArg {
  position: Vector3;
  quaternion: Quaternion;
  zoom: number | undefined;
  up: Vector3 | undefined;
  lookAt: Vector3;
  box: Box3;
  object: Box3 | Object3D | undefined;
}
declare class Bounds extends Object3D {
  camera: Camera;
  offset: number;
  duration: number;
  clip: boolean;
  private _start;
  private _goal;
  private _animationState;
  private _t;
  private _controls;
  private _controlsRemoveEventListener;
  private _cachedFitArgs;
  constructor(camera: Camera);
  dispose(): void;
  onStart(_: OnLookAtCallbackArg): void;
  onCancel(_: OnLookAtCallbackArg): void;
  onEnd(_: OnLookAtCallbackArg): void;
  easing: (t: number) => number;
  get controls(): BoundsControlsProto | null;
  set controls(controls: BoundsControlsProto | null);
  private _stop;
  /**
   * Calculates a boundary box around an `Object3D` and centers the camera accordingly.
   */
  lookAt(object: Object3D): void;
  /**
   * Calculates a boundary box around an `Object3D` and centers the camera accordingly and animates the camera's `up` vector.
   */
  lookAt(object: Object3D, up: VectorFlexibleParams): void;
  /**
   * Centers the camera's viewport on a `Box3`.
   */
  lookAt(box3: Box3): void;
  /**
   * Centers the camera's viewport on a `Box3` and animates the camera's `up` vector.
   */
  lookAt(box3: Box3, up: VectorFlexibleParams): void;
  /**
   * Look at a `Vector3`.
   */
  lookAt(target: VectorFlexibleParams): void;
  /**
   * Look at a `Vector3`, if provided. Move the camera to `position`.
   */
  lookAt(target: VectorFlexibleParams | undefined | null, position: VectorFlexibleParams): void;
  /**
   * Look at a `Vector3`, if provided. Move the camera to `position` and animate the camera's `up` vector.
   */
  lookAt(target: VectorFlexibleParams | undefined | null, position: VectorFlexibleParams, up: VectorFlexibleParams): void;
  /**
   * Rerun `lookAt` using the prior arguments. If `lookAt` has never been called, uses the `Bounds` object.
   */
  lookAt(): void;
  animate(delta: number): boolean;
}
//#endregion
//#region src/core/staging/Bounds/component.vue.d.ts
interface BoundsProps {
  /**
   * Duration of the `lookAt` animation in seconds, 1.0
   */
  duration?: number;
  /**
   * Additional distance from the target when using `lookAt` with a `Box3` or `Object3D`, 0.2
   */
  offset?: number;
  /**
   * Whether to re`lookAt` the last target when the screen is resized, false
   */
  useResize?: boolean;
  /**
   * Whether to `lookAt` the `Bounds` object when the component is mounts, false
   */
  useMounted?: boolean;
  /**
   * Whether to adjust the camera's `near` and `far` settings when using `lookAt`, false
   */
  clip?: boolean;
  /**
   * Animation's easing function. `t` and the returned value should be in the interval `[0, 1]`, cubicEaseOut
   */
  easing?: (t: number) => number;
}
declare var __VLS_7: {};
type __VLS_Slots$5 = {} & {
  default?: (props: typeof __VLS_7) => any;
};
declare const __VLS_base$4: vue0.DefineComponent<BoundsProps, {
  instance: Bounds;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {} & {
  start: (sizeProps: OnLookAtCallbackArg) => any;
  end: (sizeProps: OnLookAtCallbackArg) => any;
  cancel: (sizeProps: OnLookAtCallbackArg) => any;
}, string, vue0.PublicProps, Readonly<BoundsProps> & Readonly<{
  onStart?: ((sizeProps: OnLookAtCallbackArg) => any) | undefined;
  onEnd?: ((sizeProps: OnLookAtCallbackArg) => any) | undefined;
  onCancel?: ((sizeProps: OnLookAtCallbackArg) => any) | undefined;
}>, {
  offset: number;
  duration: number;
  useResize: boolean;
  useMounted: boolean;
  clip: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$15: __VLS_WithSlots$4<typeof __VLS_base$4, __VLS_Slots$5>;
declare const _default$5: typeof __VLS_export$15;
type __VLS_WithSlots$4<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/ContactShadows.vue.d.ts
interface ContactShadowsProps {
  /**
   * The opacity of the shadows.
   *
   * @default 1
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  opacity?: number;
  /**
   * The blur of the shadows.
   *
   * @default 1
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  blur?: number;
  /**
   * The color of the shadows.
   *
   * @default '#000000'
   * @type {TresColor}
   * @memberof ContactShadowsProps
   *
   */
  color?: TresColor;
  /**
   * The tint at the "core" of the shadows.
   *
   * @default undefined
   * @type {TresColor}
   * @memberof ContactShadowsProps
   *
   */
  tint?: TresColor;
  /**
   * The scale of the shadows.
   */
  scale?: number | [x: number, y: number];
  /**
   * The width of the shadow plane.
   *
   * @default 1
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  width?: number;
  /**
   * The height of the shadow plane.
   *
   * @default 1
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  height?: number;
  /**
   * How far the OrthographicCamera should be to capture the shadows.
   *
   * @default 10
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  far?: number;
  /**
   * Whether the shadows should be smooth or not.
   *
   * @default true
   * @type {boolean}
   * @memberof ContactShadowsProps
   *
   */
  smooth?: boolean;
  /**
   * The resolution of the shadows.
   *
   * @default 512
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  resolution?: number;
  /**
   * The number of frames to render the shadows.
   *
   * @default Infinity
   * @type {number}
   * @memberof ContactShadowsProps
   *
   */
  frames?: number;
  /**
   * Whether the shadows should write to the depth buffer or not.
   *
   * @default false
   * @type {boolean}
   * @memberof ContactShadowsProps
   *
   */
  depthWrite?: boolean;
}
declare const __VLS_export$14: vue0.DefineComponent<ContactShadowsProps, {
  instance: Group<three5.Object3DEventMap>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<ContactShadowsProps> & Readonly<{}>, {
  depthWrite: boolean;
  frames: number;
  resolution: number;
  far: number;
  height: number;
  width: number;
  scale: number | [x: number, y: number];
  color: TresColor;
  opacity: number;
  blur: number;
  tint: TresColor;
  smooth: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$12: typeof __VLS_export$14;
//#endregion
//#region src/core/staging/Fit.vue.d.ts
interface Props {
  /**
   * If `into` is:
   * - omitted or explicitly `undefined`: position/scale children to fit into a 1  1  1 `Box3` at world origin.
   * - `null`: turn off `<Fit />`; reset scale/position of children.
   * - `number`: convert argument to `Vector3(number, number, number)`.
   * - `[number, number, number]`: convert argument to `Vector3`.
   * - `Vector3`: position/scale children to fit inside a `Box3` of size `Vector3` at target objects' cumulative center.
   * - `Box3`: position/scale children to fit inside `Box3`.
   * - `Object3D`: position/scale children to fit inside calculated `Box3`. [See `THREE.Box3.setFromObject`](https://threejs.org/docs/#api/en/math/Box3.setFromObject). `<Fit />` must not contain the `Object3D` and vice-versa.
   */
  into?: number | [number, number, number] | Vector3 | Box3 | Object3D | null;
  /** [See `precise` argument in `THREE.Box3.setFromObject`](https://threejs.org/docs/index.html?q=box3#api/en/math/Box3.setFromObject) */
  precise?: boolean;
}
declare const props: Readonly<{}> & {
  readonly into: number | Object3D<three5.Object3DEventMap> | Vector3 | [number, number, number] | Box3 | null;
  readonly precise: boolean;
} & {
  readonly precise: boolean;
};
declare var __VLS_22: {};
type __VLS_Slots$4 = {} & {
  default?: (props: typeof __VLS_22) => any;
};
declare const __VLS_base$3: vue0.DefineComponent<Props, {
  instance: vue0.ShallowRef<any, any>;
  fit: (into?: typeof props.into, precise?: boolean) => void;
  update: () => void;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<Props> & Readonly<{}>, {
  precise: boolean;
  into: number | [number, number, number] | Vector3 | Box3 | Object3D | null;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$13: __VLS_WithSlots$3<typeof __VLS_base$3, __VLS_Slots$4>;
declare const _default$22: typeof __VLS_export$13;
type __VLS_WithSlots$3<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Grid.vue.d.ts
/**
       Based on
      https://github.com/Fyrestar/THREE.InfiniteGridHelper by https://github.com/Fyrestar
      and https://github.com/threlte/threlte/blob/main/packages/extras/src/lib/components/Grid/Grid.svelte
      by https://github.com/grischaerbe and https://github.com/jerzakm
*/
interface GridMaterialType {
  /** Cell size, default: 0.5 */
  cellSize?: number;
  /** Cell thickness, default: 0.5 */
  cellThickness?: number;
  /** Cell color, default: black */
  cellColor?: ColorRepresentation;
  /** Section size, default: 1 */
  sectionSize?: number;
  /** Section thickness, default: 1 */
  sectionThickness?: number;
  /** Section color, default: #2080ff */
  sectionColor?: ColorRepresentation;
  /** Follow camera, default: false */
  followCamera?: boolean;
  /** Display the grid infinitely, default: false */
  infiniteGrid?: boolean;
  /** Fade distance, default: 100 */
  fadeDistance?: number;
  /** Fade strength, default: 1 */
  fadeStrength?: number;
  /** Fade from camera (1) or origin (0), or somewhere in between, default: camera */
  fadeFrom?: number;
  /** Material side, default: THREE.BackSide */
  side?: Side;
}
type GridProps = GridMaterialType & {
  /** Default plane-geometry arguments */
  args?: ConstructorParameters<typeof PlaneGeometry>;
};
declare const __VLS_export$12: vue0.DefineComponent<GridProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<GridProps> & Readonly<{}>, {
  side: Side;
  cellSize: number;
  cellThickness: number;
  cellColor: ColorRepresentation;
  sectionSize: number;
  sectionThickness: number;
  sectionColor: ColorRepresentation;
  followCamera: boolean;
  infiniteGrid: boolean;
  fadeDistance: number;
  fadeStrength: number;
  fadeFrom: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$25: typeof __VLS_export$12;
//#endregion
//#region src/core/staging/Ocean.vue.d.ts
interface OceanProps {
  /**
   * The textureWidth of the internal WebGLRenderTarget.
   *
   * @default 512
   * @type {number}
   * @memberof OceanProps
   *
   */
  textureWidth?: number;
  /**
   * The textureHeight of the internal WebGLRenderTarget.
   *
   * @default 512
   * @type {number}
   * @memberof OceanProps
   *
   */
  textureHeight?: number;
  /**
   * The normal texture of the ocean.
   * @default 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/water/Water_1_M_Normal.jpg'
   * @type {string}
   * @memberof OceanProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  waterNormals?: string;
  /**
   * The sun direction
   * @default '[0,0,0]'
   * @type {TresVector3}
   * @memberof OceanProps
   */
  sunDirection?: TresVector3;
  /**
   * The sun color.
   *
   * @default '#fff'
   * @type {TresColor}
   * @memberof OceanProps
   *
   */
  sunColor?: TresColor;
  /**
   * The water color.
   *
   * @default '#001e0f'
   * @type {TresColor}
   * @memberof OceanProps
   *
   */
  waterColor?: TresColor;
  /**
   * The distortion scale of the reflections.
   * @default 3.7
   * @type {number}
   * @memberof OceanProps
   *
   */
  distortionScale?: number;
  /**
   * The size of the normal texture.
   *
   * @default 1
   * @type {number}
   * @memberof OceanProps
   *
   */
  size?: number;
  /**
   * The ClipBias.
   *
   * @default 0.0
   * @type {number}
   * @memberof OceanProps
   *
   */
  clipBias?: number;
  /**
   * The alpha factor.
   *
   * @default 1.0
   * @type {number}
   * @memberof OceanProps
   *
   */
  alpha?: number;
  /**
   * ThreeJs side material property.
   *
   * @default FrontSide
   * @type {TresVector3}
   * @memberof OceanProps
   *
   */
  side?: TresVector3;
}
declare var __VLS_8$1: {};
type __VLS_Slots$3 = {} & {
  default?: (props: typeof __VLS_8$1) => any;
};
declare const __VLS_base$2: vue0.DefineComponent<OceanProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<OceanProps> & Readonly<{}>, {
  side: TresVector3;
  size: number;
  textureWidth: number;
  textureHeight: number;
  clipBias: number;
  waterNormals: string;
  sunDirection: TresVector3;
  sunColor: TresColor;
  waterColor: TresColor;
  distortionScale: number;
  alpha: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$11: __VLS_WithSlots$2<typeof __VLS_base$2, __VLS_Slots$3>;
declare const _default$47: typeof __VLS_export$11;
type __VLS_WithSlots$2<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Precipitation.vue.d.ts
interface PrecipitationProps {
  /**
   * The size of the drops.
   *
   * @type {number}
   * @memberof PrecipitationProps
   * @default 0.1
   */
  size?: number;
  /**
   * The size of the precipitation area.
   *
   * @type {[number, number, number]}
   * @memberof PrecipitationProps
   * @default "[10, 10, 20]"
   */
  area?: [number, number, number];
  /**
   * The color of the shadows.
   *
   * @default '0xffffff'
   * @type {TresColor}
   * @memberof PrecipitationProps
   *
   */
  color?: TresColor;
  /**
   * Color texture of the drops.
   *
   * @type {Texture}
   * @memberof PrecipitationProps
   * @default null
   */
  map?: string | Texture | null;
  /**
   * texture of the alphaMap Drops.
   *
   * @type {Texture}
   * @memberof PrecipitationProps
   * @default null
   */
  alphaMap?: string | Texture | null;
  /**
   * enables the WebGL to know when not to render the pixel.
   *
   * @type {number}
   * @memberof PrecipitationProps
   * @default 0.01
   */
  alphaTest?: number;
  /**
   * Set the opacity of the drops.
   *
   * @type {number}
   * @memberof PrecipitationProps
   * @default 0.8
   */
  opacity?: number;
  /**
   * number of drops.
   *
   * @type {number}
   * @memberof PrecipitationProps
   * @default 5000
   */
  count?: number;
  /**
   * Speed of drops.
   *
   * @type {number}
   * @memberof PrecipitationProps
   * @default 5000
   */
  speed?: number;
  /**
   * Add randomness to the drops.
   *
   * @default 0.5
   * @type {number}
   * @memberof PrecipitationProps
   *
   */
  randomness?: number;
  /**
   * Whether the shadows should write to the depth buffer or not.
   *
   * @default false
   * @type {boolean}
   * @memberof PrecipitationProps
   *
   */
  depthWrite?: boolean;
  /**
   * show transparency on the drops texture.
   *
   * @type {boolean}
   * @memberof PrecipitationProps
   * @default true
   */
  transparent?: boolean;
  /**
   * keep the same size regardless distance.
   *
   * @type {boolean}
   * @memberof PrecipitationProps
   * @default true
   */
  sizeAttenuation?: boolean;
}
declare const __VLS_export$10: vue0.DefineComponent<PrecipitationProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<PrecipitationProps> & Readonly<{}>, {
  count: number;
  alphaTest: number;
  depthWrite: boolean;
  color: TresColor;
  transparent: boolean;
  opacity: number;
  size: number;
  speed: number;
  sizeAttenuation: boolean;
  area: [number, number, number];
  randomness: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$55: typeof __VLS_export$10;
//#endregion
//#region src/core/staging/CircleShadow.vue.d.ts
interface ShadowProps {
  color?: Color | number | string;
  offset?: number;
  opacity?: number;
  fog?: boolean;
  depthWrite?: boolean;
}
declare const __VLS_export$9: vue0.DefineComponent<ShadowProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<ShadowProps> & Readonly<{}>, {
  depthWrite: boolean;
  fog: boolean;
  color: Color | number | string;
  opacity: number;
  offset: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$10: typeof __VLS_export$9;
//#endregion
//#region src/core/staging/RandomizedLights/component.vue.d.ts
interface RandomizedLightsProps {
  /** Number of lights, 8 */
  count?: number;
  /** Radius of the jiggle, higher values make softer light, 1 */
  radius?: number;
  /** Light intensity, Math.PI */
  intensity?: number;
  /** "Ambient occlusion" to directional light ratio, lower values mean less AO, 0.5 */
  ambient?: number;
  /** If the lights cast shadows, true */
  castShadow?: boolean;
  /** Default shadow bias, 0 */
  bias?: number;
  /** Size of the lights' shadow map, 512 */
  mapSize?: number;
  /** Size of the lights' shadow camera frustum, 10 */
  size?: number;
  /** Lights' shadow camera near value, 0.5 */
  near?: number;
  /** Lights' shadow camera far value, 500 */
  far?: number;
  /** Position, [5, 5, -10] */
  position?: VectorFlexibleParams;
}
declare const __VLS_export$8: vue0.DefineComponent<RandomizedLightsProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<RandomizedLightsProps> & Readonly<{}>, {
  count: number;
  near: number;
  far: number;
  radius: number;
  size: number;
  castShadow: boolean;
  intensity: number;
  ambient: number;
  bias: number;
  mapSize: number;
  position: VectorFlexibleParams;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$57: typeof __VLS_export$8;
//#endregion
//#region src/core/staging/Sky.vue.d.ts
interface SkyProps {
  /**
   * Haziness
   * @param {number} turbidity
   */
  turbidity?: number;
  /**
   * [Rayleigh scattering](https://en.wikipedia.org/wiki/Rayleigh_scattering)
   */
  rayleigh?: number;
  /**
   * [Mie scattering](https://en.wikipedia.org/wiki/Mie_scattering) amount
   */
  mieCoefficient?: number;
  /**
   * [Mie scattering](https://en.wikipedia.org/wiki/Mie_scattering) direction
   */
  mieDirectionalG?: number;
  /**
   * Sun's elevation from the horizon, in degrees
   */
  elevation?: number;
  /**
   * Sun's [azimuth angle](https://en.wikipedia.org/wiki/Solar_azimuth_angle), in degrees  its horizontal coordinate on the horizon
   */
  azimuth?: number;
  /**
   * Sky box scale
   */
  distance?: number;
}
declare const __VLS_export$7: vue0.DefineComponent<SkyProps, {
  instance: Sky;
  sunPosition: Vector3;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SkyProps> & Readonly<{}>, {
  distance: number;
  turbidity: number;
  rayleigh: number;
  mieCoefficient: number;
  mieDirectionalG: number;
  elevation: number;
  azimuth: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$66: typeof __VLS_export$7;
//#endregion
//#region src/core/staging/Smoke.vue.d.ts
interface SmokeProps {
  /**
   * The color of the smoke.
   * @default 0xffffff
   * @type {TresColor}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  color?: TresColor;
  /**
   * The strength of the opacity.
   * @default 0.5
   * @type {number}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  opacity?: number;
  /**
   * The rotation speed of the smoke.
   * @default 0.4
   * @type {number}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  speed?: number;
  /**
   * The base width.
   * @default 4
   * @type {number}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
   */
  width?: number;
  /**
   * The base depth.
   * @default 10
   * @type {number}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/geometries/PlaneGeometry
   */
  depth?: number;
  /**
   * The number of smoke to render.
   * @default 10
   * @type {number}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  segments?: number;
  /**
   * The texture of the smoke.
   * @default 'https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png'
   * @type {string}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  texture?: string;
  /**
   * The depthTest.
   * @default true
   * @type {boolean}
   * @memberof SmokeProps
   * @see https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
   */
  depthTest?: boolean;
}
declare const __VLS_export$6: vue0.DefineComponent<SmokeProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SmokeProps> & Readonly<{}>, {
  depthTest: boolean;
  width: number;
  segments: number;
  color: TresColor;
  opacity: number;
  texture: string;
  speed: number;
  depth: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$67: typeof __VLS_export$6;
//#endregion
//#region src/core/staging/SoftShadows.vue.d.ts
interface SoftShadowsProps {
  /** Size of the light source (the larger the softer the light), default: 25 */
  size?: number;
  /** Number of samples (more samples less noise but more expensive), default: 10 */
  samples?: number;
  /** Depth focus, use it to shift the focal point (where the shadow is the sharpest), default: 0 (the beginning) */
  focus?: number;
}
declare const __VLS_export$5: vue0.DefineComponent<SoftShadowsProps, {}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SoftShadowsProps> & Readonly<{}>, {
  size: number;
  samples: number;
  focus: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$68: typeof __VLS_export$5;
//#endregion
//#region src/utils/Gradient.d.ts
type Gradient<T> = T | T[] | NormalizedGradient<T>;
type NormalizedGradient<T> = [number, T][];
//#endregion
//#region src/core/staging/Sparkles/component.vue.d.ts
interface SparkleProps {
  /**
   * Texture or image path for individual sparkles
   */
  map?: Texture | string;
  /**
   * Vertices of the geometry will be used to emit sparkles. Geometry normals are used for sparkles' traveling direction and for responding to the directional light prop.
   *
   * - If provided, the component will use the passed geometry.
   * - If no geometry is provided, the component will try to make a copy of the parent object's geometry.
   * - If no parent geometry exists, the component will create and use an IcosphereGeometry.
   */
  geometry?: Object3D | BufferGeometry;
  /**
   * Particles "light up" when their normal "faces" the light. If no `directionalLight` is provided, the default "up" vector will be used.
   */
  directionalLight?: Object3D;
  /**
   * Particle lifetime in seconds
   */
  lifetimeSec?: number;
  /**
   * Particle cooldown in seconds  time between lifetime end and respawn
   */
  cooldownSec?: number;
  /**
   * Number from 0-1 indicating how closely the particle needs to be faced towards the light to "light up". (Lower == more flexible)
   */
  normalThreshold?: number;
  /**
   * Scale of the noise period (lower == more slowly cycling noise)
   */
  noiseScale?: number;
  /**
   * Noise coefficient applied to particle scale
   */
  scaleNoise?: number;
  /**
   * Noise coefficient applied to particle offset
   */
  offsetNoise?: number;
  /**
   * Noise coefficient applied to particle lifetime
   */
  lifetimeNoise?: number;
  /**
   * Particle scale multiplier
   */
  size?: number;
  /**
   * Opacity multiplier
   */
  alpha?: number;
  /**
   * Offset multiplier
   */
  offset?: number;
  /**
   * Surface distance multiplier
   */
  surfaceDistance?: number;
  /**
   * '*Sequence' props: specify how a particle changes as it "progresses". See also "mix*" props.
   *
   * Color sequence as particles progress
   */
  sequenceColor?: Gradient<TresColor>;
  /**
   * Opacity sequence as particles progress
   */
  sequenceAlpha?: Gradient<number>;
  /**
   * Distance sequence as particles progress
   */
  sequenceOffset?: Gradient<VectorFlexibleParams>;
  /**
   * Noise sequence as particles progress
   */
  sequenceNoise?: Gradient<VectorFlexibleParams>;
  /**
   * Size sequence as particles progress
   */
  sequenceSize?: Gradient<number>;
  /**
   * Distance from surface (along normal) as particles progress
   */
  sequenceSurfaceDistance?: Gradient<number>;
  /**
   * 'mix*' props: A particle "progresses" with a mix of two factors:
   *
   * its normal "facing" the directionalLight
   * its lifetime
   *
   * 'mix*' props specify the relationship between the two factors.
   *
   * How is a particle's progress for color calculated? (0: normal, 1: particle lifetime)
   */
  mixColor?: number;
  /**
   * How is a particle's progress for alpha calculated? (0: normal, 1: particle lifetime)
   */
  mixAlpha?: number;
  /**
   * How is a particle's progress for offset calculated? (0: normal, 1: particle lifetime)
   */
  mixOffset?: number;
  /**
   * How is a particle's progress for size calculated? (0: normal, 1: particle lifetime)
   */
  mixSize?: number;
  /**
   * How is a particle's progress for surface distance calculated? (0: normal, 1: particle lifetime)
   */
  mixSurfaceDistance?: number;
  /**
   * How is a particle's progress for lifetime calculated? (0: normal, 1: particle lifetime)
   */
  mixNoise?: number;
  /**
   * Material blending
   */
  blending?: Blending;
  /**
   * Material transparency
   */
  transparent?: boolean;
  /**
   * Material depth write
   */
  depthWrite?: boolean;
}
declare const __VLS_export$4: vue0.DefineComponent<SparkleProps, {
  instance: Points<BufferGeometry<three5.NormalOrGLBufferAttributes, three5.BufferGeometryEventMap>, ShaderMaterial, three5.Object3DEventMap>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<SparkleProps> & Readonly<{}>, {
  map: Texture | string;
  depthWrite: boolean;
  transparent: boolean;
  size: number;
  blending: Blending;
  offset: number;
  alpha: number;
  geometry: Object3D | BufferGeometry;
  directionalLight: Object3D;
  lifetimeSec: number;
  cooldownSec: number;
  normalThreshold: number;
  noiseScale: number;
  scaleNoise: number;
  offsetNoise: number;
  lifetimeNoise: number;
  surfaceDistance: number;
  sequenceColor: Gradient<TresColor>;
  sequenceAlpha: Gradient<number>;
  sequenceOffset: Gradient<VectorFlexibleParams>;
  sequenceNoise: Gradient<VectorFlexibleParams>;
  sequenceSize: Gradient<number>;
  sequenceSurfaceDistance: Gradient<number>;
  mixColor: number;
  mixAlpha: number;
  mixOffset: number;
  mixSize: number;
  mixSurfaceDistance: number;
  mixNoise: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$69: typeof __VLS_export$4;
//#endregion
//#region src/core/staging/Stage.vue.d.ts
interface StageProps {
  /** Lighting setup, default: "rembrandt" */
  lighting?: null | undefined | false | 'rembrandt' | 'portrait' | 'upfront' | 'soft' | {
    main: [x: number, y: number, z: number];
    fill: [x: number, y: number, z: number];
  };
  /** Controls the ground shadows, default: "contact" */
  shadows?: boolean | 'contact' | 'accumulative' | StageShadows;
  /** Optionally wraps and thereby centers the models using <Bounds>, can also be a camera offset, default: true */
  adjustCamera?: boolean | number;
  /** The default environment, default: { preset: "city" } */
  environment?: EnvironmentPresetsType | Partial<EnvironmentOptions> | null;
  /** Lighting intensity, `0` removes lights, default: 0.5 */
  intensity?: number;
  /** To adjust alignment, default: undefined */
  align?: Partial<AlignProps>;
}
type StageShadows = Partial<AccumulativeShadowsProps> & Partial<RandomizedLightsProps> & Partial<ContactShadowsProps> & {
  type: 'contact' | 'accumulative';
  /** Shadow plane offset, default: 0 */
  offset?: number;
  /** Shadow bias, default: -0.0001 */
  bias?: number;
  /** Shadow normal bias, default: 0 */
  normalBias?: number;
  /** Shadow map size, default: 1024 */
  size?: number;
};
declare var __VLS_45: {};
type __VLS_Slots$2 = {} & {
  default?: (props: typeof __VLS_45) => any;
};
declare const __VLS_base$1: vue0.DefineComponent<StageProps, {
  instance: vue0.ShallowRef<typeof Group | undefined, typeof Group | undefined>;
  update: () => void;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<StageProps> & Readonly<{}>, {
  intensity: number;
  lighting: false | "rembrandt" | "portrait" | "upfront" | "soft" | {
    main: [x: number, y: number, z: number];
    fill: [x: number, y: number, z: number];
  } | null;
  shadows: boolean | "contact" | "accumulative" | StageShadows;
  adjustCamera: boolean | number;
  environment: EnvironmentPresetsType | Partial<EnvironmentOptions> | null;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$3: __VLS_WithSlots$1<typeof __VLS_base$1, __VLS_Slots$2>;
declare const _default$71: typeof __VLS_export$3;
type __VLS_WithSlots$1<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/Stars.vue.d.ts
interface StarsProps {
  /**
   * The size of the stars.
   *
   * @type {number}
   * @memberof StarsProps
   * @default 0.1
   */
  size?: number;
  /**
   * keep the same size regardless distance.
   *
   * @type {boolean}
   * @memberof StarsProps
   * @default true
   */
  sizeAttenuation?: boolean;
  /**
   * show transparency on the stars texture.
   *
   * @type {boolean}
   * @memberof StarsProps
   * @default true
   */
  transparent?: boolean;
  /**
   * enables the WebGL to know when not to render the pixel.
   *
   * @type {number}
   * @memberof StarsProps
   * @default 0.01
   */
  alphaTest?: number;
  /**
   * number of stars.
   *
   * @type {number}
   * @memberof StarsProps
   * @default 5000
   */
  count?: number;
  /**
   * depth of star's shape.
   *
   * @type {number}
   * @memberof StarsProps
   * @default 50
   */
  depth?: number;
  /**
   * Radius of star's shape.
   *
   * @type {number}
   * @memberof StarsProps
   * @default 100
   */
  radius?: number;
  /**
   * texture of the stars.
   *
   * @type {string}
   * @memberof StarsProps
   * @default null
   */
  alphaMap?: null;
}
declare const __VLS_export$2: vue0.DefineComponent<StarsProps, {
  instance: vue0.ShallowRef<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<StarsProps> & Readonly<{}>, {
  count: number;
  alphaTest: number;
  radius: number;
  transparent: boolean;
  size: number;
  alphaMap: null;
  depth: number;
  sizeAttenuation: boolean;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$72: typeof __VLS_export$2;
//#endregion
//#region src/core/staging/useEnvironment/component.vue.d.ts
declare var __VLS_8: {};
type __VLS_Slots$1 = {} & {
  default?: (props: typeof __VLS_8) => any;
};
declare const __VLS_base: vue0.DefineComponent<EnvironmentOptions, {
  texture: Ref<Texture | CubeTexture | null, Texture | CubeTexture | null>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<EnvironmentOptions> & Readonly<{}>, {
  frames: number;
  resolution: number;
  near: number;
  far: number;
  path: string;
  blur: number;
  background: boolean | string;
  files: string | string[];
  preset: EnvironmentPresetsType;
  backgroundIntensity: number;
  environmentIntensity: number;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const __VLS_export$1: __VLS_WithSlots<typeof __VLS_base, __VLS_Slots$1>;
declare const _default$19: typeof __VLS_export$1;
type __VLS_WithSlots<T, S> = T & {
  new (): {
    $slots: S;
  };
};
//#endregion
//#region src/core/staging/useEnvironment/lightformer/index.vue.d.ts
type __VLS_Props = {
  args?: any[];
  form?: 'circle' | 'ring' | 'rect' | any;
  toneMapped?: boolean;
  map?: Texture;
  intensity?: number;
  color?: any;
};
declare const __VLS_export: vue0.DefineComponent<__VLS_Props, {
  mesh: vue0.Ref<any, any>;
}, {}, {}, {}, vue0.ComponentOptionsMixin, vue0.ComponentOptionsMixin, {}, string, vue0.PublicProps, Readonly<__VLS_Props> & Readonly<{}>, {
  map: Texture;
  color: any;
  toneMapped: boolean;
  args: any[];
  intensity: number;
  form: "circle" | "ring" | "rect" | any;
}, {}, {}, {}, string, vue0.ComponentProvideOptions, false, {}, any>;
declare const _default$35: typeof __VLS_export;
//#endregion
//#region src/utils/index.d.ts
/**
 * Update the function signature to explicitly specify the type of the props parameter
 *
 * @export
 * @template T
 * @template K
 * @param {T} obj
 * @param {K[]} props
 * @return {*}  {Pick<T, K>}
 */
declare function pick<T extends object, K extends keyof T>(obj: T, props: K[]): Pick<T, K>;
/**
 * Check if the object has a setter for the given property
 *
 * @export
 * @param {*} obj
 * @param {string} prop
 * @return {*}  {boolean}
 */
declare function hasSetter(obj: any, prop: string): boolean;
declare function extractBindingPosition(binding: any): Vector3;
//#endregion
export { _default as AccumulativeShadows, _default$1 as Align, _default$2 as AnimatedSprite, _default$3 as Backdrop, BakeShadows, BaseCameraControls, _default$4 as Billboard, _default$5 as Bounds, _default$6 as Box, _default$7 as CameraControls, _default$8 as CatmullRomCurve3, _default$9 as Circle, _default$10 as CircleShadow, _default$11 as Cone, _default$12 as ContactShadows, _default$13 as CubeCamera, _default$14 as CubicBezierLine, _default$15 as CustomShaderMaterial, _default$16 as Cylinder, _default$17 as Dodecahedron, _default$18 as Edges, _default$19 as Environment, _default$20 as FBXModel, _default$21 as Fbo, FboOptions, _default$22 as Fit, _default$23 as GLTFModel, GlobalAudio, _default$24 as GradientTexture, _default$25 as Grid, _default$26 as Helper, _default$27 as HolographicMaterial, _default$28 as Html, _default$29 as Icosahedron, _default$30 as Image, _default$31 as KeyboardControls, _default$32 as LOD, _default$33 as Lensflare, _default$34 as Levioso, _default$35 as Lightformer, _default$36 as Line2, _default$37 as MapControls, _default$38 as MarchingCube, _default$39 as MarchingCubes, _default$40 as MarchingPlane, _default$41 as Mask, _default$42 as MeshDiscardMaterial, _default$43 as MeshGlassMaterial, _default$44 as MeshReflectionMaterial, _default$45 as MeshWobbleMaterial, _default$46 as MouseParallax, _default$47 as Ocean, _default$48 as Octahedron, _default$49 as OrbitControls, _default$50 as Outline, _default$51 as Plane, _default$52 as PointMaterial, _default$53 as PointerLockControls, _default$54 as PositionalAudio, _default$55 as Precipitation, _default$56 as QuadraticBezierLine, _default$57 as RandomizedLights, _default$58 as Reflector, _default$59 as Ring, _default$60 as RoundedBox, SVGLayer, _default$61 as Sampler, _default$62 as ScreenQuad, _default$63 as ScreenSizer, _default$64 as ScreenSpace, _default$65 as ScrollControls, _default$66 as Sky, _default$67 as Smoke, _default$68 as SoftShadows, _default$69 as Sparkles, _default$70 as Sphere, _default$71 as Stage, _default$72 as Stars, Stats, StatsGl, _default$73 as Superformula, _default$74 as Tetrahedron, _default$75 as Text3D, _default$76 as Torus, _default$77 as TorusKnot, _default$78 as TransformControls, TransformFn, _default$79 as Tube, UseFBXOptions, UseGLTFOptions, _default$80 as UseSVG, UseSVGOptions, _default$81 as UseTexture, extractBindingPosition, hasSetter, pick, useAnimations, useEnvironment, useFBO, useFBX, useGLTF, useGLTFExporter, useIntersect, useMask, useProgress, useSVG, useSurfaceSampler, useSurfaceSamplerProps, useTexture, useTextures, useVideoTexture };